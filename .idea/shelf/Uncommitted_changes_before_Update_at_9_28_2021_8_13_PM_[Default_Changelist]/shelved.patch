Index: BackTest.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import threading\r\nfrom datetime import datetime, date\r\nimport time\r\n\r\nimport numpy\r\nimport pandas as pd\r\n\r\nfrom binance.client import Client\r\nfrom Algorithm import OfflineAlgorithm\r\nfrom Strategy import ICHIMOKU_2_Strategy, ICHIMOKU_CCI_WilliamsR_Strategy, ICHIMOKU_STOCASTIC_Strategy, \\\r\n    ICHIMOKU_Strategy_Test, ICHIMOKU_Strategy_HMA, ICHIMOKU_Strategy_HMA_Keltner\r\nfrom IO import CSVFiles, FileWorking\r\n\r\n\r\nclass Algorithm_1(OfflineAlgorithm):\r\n\r\n    def __init__(self, candle):\r\n        self.window1 = [9, 18, 24, 36]\r\n        self.window2 = [24, 48, 72]\r\n        self.window3_ = [48, 96, 144]\r\n        self.t = [18, 26, 48]\r\n        self.a = [0, 0.01]\r\n        self.b = [0.04, 0.05, 0.06]\r\n        self.SL_arr = [0.025, 0.05]\r\n        # self.RR_arr = [1, 1.5, 2, 2.5, 3]\r\n\r\n        # self.window1 = [36]\r\n        # self.window2 = [48]\r\n        # self.window3_ = [144]\r\n        # self.t = [18]\r\n        # self.a = [0]\r\n        # self.b = [0.04]\r\n        # self.SL_arr = [0.025, 0.05]\r\n\r\n        self.fast = [12]\r\n        self.slow = [78]\r\n        self.signal = [18]\r\n\r\n        global klines\r\n        use_offline_data = True\r\n        if use_offline_data:\r\n            klines = FileWorking.ReadKlines(\"Data\\\\BTCUSDT_1HOUR_1.1.2019_1.1.2020.txt\")\r\n        else:\r\n            klines = candle.getKlines(\"BNBUSDT\", Client.KLINE_INTERVAL_1HOUR, \"1 Jan, 2018\", \"1 Jan, 2020\")\r\n            FileWorking.WriteKlines(klines, \"Data\\\\BNBUSDT_1HOUR_1.1.2018_1.1.2020.txt\")\r\n        candle.unpackCandle(klines)\r\n        high = pd.Series(candle.high)\r\n        low = pd.Series(candle.low)\r\n\r\n        self.klines = klines\r\n        self.close_data = candle.close\r\n\r\n        self.ichi_2_strategy = ICHIMOKU_2_Strategy(high, low, self.close_data)\r\n\r\n        self.file = CSVFiles(\"Strategy_2-New-2019_2020-BTCUSDT.csv\")\r\n\r\n    def BuyStrategy(self, i, win1, win2, win3, t, a, b, computeIndicator):\r\n        if computeIndicator:\r\n            self.ichi_2_strategy.ComputeIchimoku_A(win1, win2)\r\n            self.ichi_2_strategy.ComputeIchimoku_B(win2, win3)\r\n            self.ichi_2_strategy.ComputeIchimoku_Base_Line(win1, win2)\r\n            self.ichi_2_strategy.ComputeIchimoku_Conversion_Line(win1, win2)\r\n            self.ichi_2_strategy.ComputeMACD(self.fast[0], self.slow[0], self.signal[0])\r\n        return self.ichi_2_strategy.BuyStrategy(i, t, a, b)\r\n\r\n    def WriteResult(self, header, rows):\r\n        self.file.SetCSVFieldName(header)\r\n        self.file.WriteHeader()\r\n        self.file.WriteRows(rows)\r\n\r\n    def RunAlgorithm(self):\r\n        fieldnames = ['Strategy', 'Win1', 'Win2', 'Win3', 'T', 'A', 'B', 'Total Net Profit',\r\n                      'Gross Profit', 'Max Profit', 'Gross Loss', 'Max Loss', 'Profit Factor',\r\n                      'Profit Trade (%)', 'Loss Trade (%)', 'Total Trade', 'Expected Payoff', 'Max Consecutive Wins',\r\n                      'Avg Consecutive Wins', 'Max Consecutive Loss', 'Avg Consecutive Loss',\r\n                      'Max Draw Down (%)', \"Missing Profit\"]\r\n        rows = []\r\n        for win1 in self.window1:\r\n            for win2 in self.window2:\r\n                for win3 in self.window3_:\r\n                    for t in self.t:\r\n                        print(win1, \" \", win2, \" \", win3, \" \", t, \" \")\r\n                        for a in self.a:\r\n                            for b in self.b:\r\n                                # for SL in self.SL_arr:\r\n                                ICHIMOKU_fill = True\r\n                                balance = 1000\r\n                                isNotPos = True\r\n                                balance_arr = []\r\n                                max_balance = balance\r\n                                min_balance = balance\r\n                                Max_DD_arr = [0]\r\n                                profit = 0\r\n                                profit_arr = [0]\r\n                                loss = 0\r\n                                loss_arr = [0]\r\n                                profit_count = 0\r\n                                loss_count = 0\r\n                                temp_profit_count = 0\r\n                                max_profit_count = 0\r\n                                avg_profit_count = []\r\n                                temp_loss_count = 0\r\n                                max_loss_count = 0\r\n                                avg_loss_count = []\r\n                                max_price = 0\r\n                                buy_price = 0\r\n                                missing_profit = []\r\n                                for i in range(1, len(self.klines) - 1):\r\n                                    if self.BuyStrategy(i, win1, win2, win3, t, a, b, ICHIMOKU_fill) and isNotPos:\r\n                                        isNotPos = False\r\n                                        buy_price = self.close_data[i]\r\n                                        max_price = buy_price\r\n                                        order_time = datetime.utcfromtimestamp(self.klines[i][0] / 1000)\r\n                                        # print(\"Win1=\", win1, \" Win2=\", win2, \"T=\", t, \" Win3=\", win3)\r\n                                        # print(\"Order \", profit_count + loss_count, \" Buy_Price = \", buy_price,\r\n                                        #       \"Date = \", order_time)\r\n                                        i += 1\r\n                                        volume = balance\r\n                                    if not isNotPos:\r\n                                        if self.ichi_2_strategy.SellStrategy(i, t):# or\\\r\n                                        #     ((buy_price - self.close_data[i]) / buy_price) > SL:\r\n                                            if self.close_data[i] - buy_price < 0:\r\n                                                loss += ((buy_price - self.close_data[i]) / buy_price) * volume\r\n                                                loss_arr.append(((buy_price - self.close_data[i]) / buy_price) * volume)\r\n                                                balance -= ((buy_price - self.close_data[i]) / buy_price) * volume\r\n                                                balance_arr.append(balance)\r\n                                                # print(\"(Loss) Balance = \", balance, \"Date = \",  datetime.utcfromtimestamp(self.klines[i][0] / 1000),\r\n                                                #       \"Sell Price = \", self.close_data[i] , \"Max Price = \", max_price,\r\n                                                #       \"Missing Profit = \",(max_price - self.close_data[i]) / max_price)\r\n                                                loss_count += 1\r\n                                                temp_loss_count += 1\r\n                                                if max_profit_count < temp_profit_count:\r\n                                                    max_profit_count = temp_profit_count\r\n                                                if temp_profit_count != 0:\r\n                                                    avg_profit_count.append(temp_profit_count)\r\n                                                temp_profit_count = 0\r\n                                                if min_balance > balance:\r\n                                                    min_balance = balance\r\n                                                    Max_DD_arr[-1] = ((max_balance - min_balance) / max_balance)\r\n                                                isNotPos = True\r\n                                                # writer.writerow({'Order': profit_count + loss_count, 'Price': buy_price,\r\n                                                #                  'Time': order_time, 'Sell Time': klines[i][0],\r\n                                                #                  'Loss/Profit': \"Loss\", 'Sell Price': close_arr[i],\r\n                                                #                  'Volume': volume})\r\n                                            else:\r\n                                                profit += ((self.close_data[i] - buy_price) / buy_price) * volume\r\n                                                profit_arr.append(((self.close_data[i] - buy_price) / buy_price) * volume)\r\n                                                balance += ((self.close_data[i] - buy_price) / buy_price) * volume\r\n                                                balance_arr.append(balance)\r\n                                                # print(\"(Profit) Balance = \", balance, \"Date = \",  datetime.utcfromtimestamp(self.klines[i][0] / 1000),\r\n                                                #       \"Sell Price = \", self.close_data[i] , \"Max Price = \", max_price,\r\n                                                #       \"Missing Profit = \",(max_price - self.close_data[i]) / max_price)\r\n                                                profit_count += 1\r\n                                                temp_profit_count += 1\r\n                                                if max_loss_count < temp_loss_count:\r\n                                                    max_loss_count = temp_loss_count\r\n                                                if temp_loss_count != 0:\r\n                                                    avg_loss_count.append(temp_loss_count)\r\n                                                temp_loss_count = 0\r\n                                                if max_balance < balance:\r\n                                                    max_balance = balance\r\n                                                    min_balance = balance\r\n                                                    Max_DD_arr.append((max_balance - min_balance) / max_balance)\r\n                                                isNotPos = True\r\n                                            missing_profit.append((max_price - self.close_data[i]) / max_price)\r\n                                                # writer.writerow({'Order': profit_count + loss_count, 'Price': buy_price,\r\n                                                #                  'Time': order_time, 'Sell Time': klines[i][0],\r\n                                                #                  'Loss/Profit': \"Profit\", 'Sell Price': close_arr[i],\r\n                                                #                  'Volume': volume})\r\n                                    if max_price < self.close_data[i]:\r\n                                        max_price = self.close_data[i]\r\n                                    ICHIMOKU_fill = False\r\n                                # plt.imshow(balance)\r\n\r\n                                # plt.plot(balance_arr)\r\n                                # plt.show()\r\n                                trade_count = profit_count + loss_count\r\n                                if temp_profit_count != 0:\r\n                                    avg_profit_count.append(temp_profit_count)\r\n                                avg_profit = numpy.average(avg_profit_count)\r\n                                if temp_loss_count != 0:\r\n                                    avg_loss_count.append(temp_loss_count)\r\n                                avg_loss = numpy.average(avg_loss_count)\r\n                                # print(\"Total order = \", trade_count ,\"SL =\", SL, \"RR = \", RR, \"Balance = \", balance)\r\n                                if loss == 0:\r\n                                    profit_factor = profit\r\n                                else:\r\n                                    profit_factor = profit / loss\r\n\r\n                                try:\r\n                                    row = [\"ICHIMOKU_Strategy\", str(win1), str(win2), str(win3), t, a, b,\r\n                                           balance - 1000, profit, numpy.max(profit_arr), loss, numpy.max(loss_arr),\r\n                                           profit_factor, profit_count / trade_count, loss_count / trade_count, trade_count,\r\n                                           (balance - 1000) / trade_count, max_profit_count, avg_profit, max_loss_count,\r\n                                           avg_loss, numpy.max(Max_DD_arr) * 100, sum(missing_profit)]\r\n                                    rows.append(row)\r\n                                except ZeroDivisionError:\r\n                                    row_zero_division = [\"ICHIMOKU_Strategy\", str(win1), str(win2), str(win3), t,\r\n                                                         a, b, balance - 1000, profit, numpy.max(profit_arr), loss,\r\n                                                         numpy.max(loss_arr), profit_factor, 0, 0, trade_count, 0,\r\n                                                         max_profit_count, avg_profit, max_loss_count, avg_loss,\r\n                                                         numpy.max(Max_DD_arr) * 100, sum(missing_profit)]\r\n                                    rows.append(row_zero_division)\r\n        self.WriteResult(fieldnames, rows)\r\n\r\nclass Algorithm_2(OfflineAlgorithm):\r\n    klines = []\r\n    ichi_2_strategy = []\r\n    def __init__(self, candle, currency):\r\n        self.window1 = [9, 18, 24, 36]\r\n        self.window2 = [24, 48, 72]\r\n        self.window3 = [48, 96, 144]\r\n        self.t = [18, 26, 48]\r\n        self.a = [0, 0.01]\r\n        self.b = [0.04, 0.05, 0.06]\r\n        # self.SL_arr = [0.025, 0.05]\r\n\r\n        # self.window1 = [18]\r\n        # self.window2 = [24]\r\n        # self.window3 = [96]\r\n        # self.t = [18]\r\n        # self.a = [0]\r\n        # self.b = [0.05]\r\n\r\n        start_time = \"1.1.2020\"\r\n        end_time = \"1.1.2021\"\r\n\r\n        self.currency = currency\r\n        use_offline_data = True\r\n        for i in self.currency:\r\n            if use_offline_data:\r\n                self.klines.append(FileWorking.ReadKlines(\"Data\\\\\" + i + \"_1HOUR_\" + start_time + \"_\" + end_time + \".txt\"))\r\n            else:\r\n                self.klines.append(candle.getKlines(i, Client.KLINE_INTERVAL_1HOUR, \"1 Jan, 2018\", \"1 Jan, 2020\"))\r\n                FileWorking.WriteKlines(klines[-1], \"Data\\\\\" + i + \"_1HOUR_\" + start_time + \"_\" + end_time + \".txt\")\r\n            candle.unpackCandle(self.klines[-1])\r\n            high = pd.Series(candle.high)\r\n            low = pd.Series(candle.low)\r\n\r\n            self.close_data = candle.close\r\n\r\n            self.ichi_2_strategy.append(ICHIMOKU_2_Strategy(high, low, self.close_data))\r\n\r\n        self.file = CSVFiles(\"Strategy_2-New-2020_2021-BNBBTC.csv\")\r\n        self.result_row = []\r\n\r\n    def CreateThread(self, main_param, second_param):\r\n        try:\r\n            self.th_sec = threading.Thread(target=self.SecondThread, args=(second_param,))\r\n            self.th_sec.start()\r\n            time.sleep(1)\r\n            self.th_main = threading.Thread(target=self.MainThread, args=(main_param, second_param,))\r\n            self.th_main.start()\r\n        except:\r\n            print(\"Error: unable to start thread\")\r\n\r\n    def RunAlgorithm(self):\r\n        fieldnames = ['Strategy', 'Win1', 'Win2', 'Win3', 'T', 'A', 'B', 'Total Net Profit',\r\n                      'Gross Profit', 'Max Profit', 'Gross Loss', 'Max Loss', 'Profit Factor',\r\n                      'Profit Trade (%)', 'Loss Trade (%)', 'Total Trade', 'Expected Payoff', 'Max Consecutive Wins',\r\n                      'Avg Consecutive Wins', 'Max Consecutive Loss', 'Avg Consecutive Loss',\r\n                      'Max Draw Down (%)', 'Max Draw Down (Time)', 'ETH Profit', 'ETH Loss', 'ETH Profit Trade (%)',\r\n                      'ETH Loss Trade (%)', 'ETH Total Trade', 'ETH Missing Profit']\r\n\r\n        main_thread_param = {\"Win1\": 36, \"Win2\": 72, \"Win3\": 96, \"t\": 26, \"a\": 0.01, \"b\": 0.06}\r\n        for win1 in self.window1:\r\n            for win2 in self.window2:\r\n                for win3 in self.window3:\r\n                    for t in self.t:\r\n                        print(win1, \" \", win2, \" \", win3, \" \", t, \" \")\r\n                        for a in self.a:\r\n                            for b in self.b:\r\n                                second_thread_param = {\"Win1\": win1, \"Win2\": win2, \"Win3\": win3, \"t\": t, \"a\": a, \"b\": b}\r\n                                self.CreateThread(main_thread_param, second_thread_param)\r\n                                self.th_main.join()\r\n                                self.th_sec.join()\r\n        self.WriteResult(fieldnames, self.result_row)\r\n\r\n    def SecondThread(self, param):\r\n        self.BuySignal = [False] * len(self.klines[-1])\r\n        update_strategy = True\r\n        isNotPos = True\r\n        j = 1\r\n        while j < len(self.klines[-1]) - 1:\r\n            # print(\"EB = \", i)\r\n            # BuySignal = False\r\n            if update_strategy:\r\n                self.ichi_2_strategy[-1].ComputeIchimoku_A(param[\"Win1\"], param[\"Win2\"])\r\n                self.ichi_2_strategy[-1].ComputeIchimoku_B(param[\"Win2\"], param[\"Win3\"])\r\n                self.ichi_2_strategy[-1].ComputeIchimoku_Base_Line(param[\"Win1\"], param[\"Win2\"])\r\n                self.ichi_2_strategy[-1].ComputeIchimoku_Conversion_Line(param[\"Win1\"], param[\"Win2\"])\r\n            if self.ichi_2_strategy[-1].BuyStrategy(j, param[\"t\"], param[\"a\"], param[\"b\"]) and isNotPos:\r\n                self.BuySignal[j] = True\r\n                isNotPos = False\r\n            elif not isNotPos:\r\n                if j - param[\"t\"] - 1 > 0:\r\n                    if self.ichi_2_strategy[-1].SellStrategy(j, param[\"t\"]):\r\n                        self.BuySignal[j] = False\r\n                        isNotPos = True\r\n                    else:\r\n                        self.BuySignal[j] = True\r\n            update_strategy = False\r\n            j += 1\r\n\r\n    def MainThread(self, param, second_param):\r\n        update_strategy = True\r\n        balance_dict = {\"Current\": 1000, \"Max\": 1000, \"Min\": 1000}\r\n\r\n        isNotPos = {self.currency[0]: True, self.currency[1]: True}\r\n        balance_arr = []\r\n        buy_price = {}\r\n        Max_DD_arr = []\r\n        profit_arr = []\r\n        loss_arr = []\r\n        profit_count = 0\r\n        profit_count_arr = []\r\n        loss_count = 0\r\n        loss_count_arr = []\r\n        secondery_max_price = 0\r\n        secondery_missing_profit = []\r\n        secondery_profit = []\r\n        secondery_loss = []\r\n        for i in range(1, len(self.klines[0]) - 1):\r\n            if update_strategy:\r\n                self.ichi_2_strategy[0].ComputeIchimoku_A(param[\"Win1\"], param[\"Win2\"])\r\n                self.ichi_2_strategy[0].ComputeIchimoku_B(param[\"Win2\"], param[\"Win3\"])\r\n                self.ichi_2_strategy[0].ComputeIchimoku_Base_Line(param[\"Win1\"], param[\"Win2\"])\r\n                self.ichi_2_strategy[0].ComputeIchimoku_Conversion_Line(param[\"Win1\"], param[\"Win2\"])\r\n            if self.ichi_2_strategy[0].BuyStrategy(i, param[\"t\"], param[\"a\"], param[\"b\"])\\\r\n                    and isNotPos[self.currency[0]] and isNotPos[self.currency[1]]:\r\n                if self.BuySignal[i]:\r\n                    buy_price[self.currency[1]] = self.ichi_2_strategy[1].close_data[i]\r\n                    isNotPos[self.currency[1]] = False\r\n                    secondery_max_price = self.ichi_2_strategy[-1].close_data[i]\r\n                    # print(\"Order \", len(profit_count_arr) + len(loss_count_arr),\r\n                    #       \" Buy_Price_\" + self.currency[1] + \" = \",\r\n                    #       buy_price[self.currency[1]], \" Volume = \",\r\n                    #       balance_dict[\"Current\"], \" Date = \",\r\n                    #       datetime.utcfromtimestamp(self.klines[0][i][0] / 1000))\r\n                else:\r\n                    buy_price[self.currency[0]] = self.ichi_2_strategy[0].close_data[i]\r\n                    isNotPos[self.currency[0]] = False\r\n                    # print(\"Order \", len(profit_count_arr) + len(loss_count_arr),\r\n                    #       \" Buy_Price_\" + self.currency[0] + \" = \",\r\n                    #       buy_price[self.currency[0]], \" Volume = \",\r\n                    #       balance_dict[\"Current\"], \" Date = \",\r\n                    #       datetime.utcfromtimestamp(self.klines[0][i][0] / 1000))\r\n                i += 1\r\n                self.volume = balance_dict[\"Current\"]\r\n            if not isNotPos[self.currency[1]]:\r\n                if self.ichi_2_strategy[0].SellStrategy(i, param[\"t\"]):  # or\\\r\n                    # ((buy_price - close_arr[i]) / buy_price) > SL:\r\n                    if self.ichi_2_strategy[1].close_data[i] - buy_price[self.currency[1]] < 0:\r\n                        loss = ((buy_price[self.currency[1]] - self.ichi_2_strategy[1].close_data[i]) /\r\n                                buy_price[self.currency[1]]) * self.volume\r\n                        loss_arr.append(loss)\r\n                        balance_dict[\"Current\"] -= loss\r\n                        balance_arr.append(balance_dict[\"Current\"])\r\n                        # print(\"(Loss) Balance = \", balance_dict[\"Current\"], \"Sell_Price_\" + self.currency[1] + \" = \",\r\n                        #       self.ichi_2_strategy[1].close_data[i],\r\n                        #       \"Date = \", datetime.utcfromtimestamp(self.klines[0][i][0] / 1000))\r\n                        loss_count += 1\r\n                        profit_count_arr.append(profit_count)\r\n                        profit_count = 0\r\n                        if balance_dict[\"Min\"] > balance_dict[\"Current\"]:\r\n                            balance_dict[\"Min\"] = balance_dict[\"Current\"]\r\n                            Max_DD_arr.append((balance_dict[\"Max\"] - balance_dict[\"Min\"]) / balance_dict[\"Max\"])\r\n                        isNotPos[self.currency[1]] = True\r\n                        secondery_loss.append((buy_price[self.currency[1]] - self.ichi_2_strategy[1].close_data[i]) /\r\n                                buy_price[self.currency[1]])\r\n                        # writer.writerow({'Order': profit_count + loss_count, 'Price': buy_price,\r\n                        #                  'Time': order_time, 'Sell Time': klines[i][0],\r\n                        #                  'Loss/Profit': \"Loss\", 'Sell Price': close_arr[i],\r\n                        #                  'Volume': volume})\r\n                    else:\r\n                        profit = ((self.ichi_2_strategy[1].close_data[i] - buy_price[self.currency[1]]) /\r\n                                  buy_price[self.currency[1]]) * self.volume\r\n                        profit_arr.append(profit)\r\n                        balance_dict[\"Current\"] += profit\r\n                        balance_arr.append(balance_dict[\"Current\"])\r\n                        # print(\"(Profit) Balance = \", balance_dict[\"Current\"], \"Sell_Price_\" + self.currency[1] + \" = \",\r\n                        #       self.ichi_2_strategy[1].close_data[i],\r\n                        #       \"Date = \", datetime.utcfromtimestamp(self.klines[0][i][0] / 1000))\r\n                        profit_count += 1\r\n                        loss_count_arr.append(loss_count)\r\n                        loss_count = 0\r\n                        if balance_dict[\"Max\"] < balance_dict[\"Current\"]:\r\n                            balance_dict[\"Max\"] = balance_dict[\"Current\"]\r\n                            balance_dict[\"Min\"] = balance_dict[\"Current\"]\r\n                            Max_DD_arr.append((balance_dict[\"Max\"] - balance_dict[\"Min\"]) / balance_dict[\"Max\"])\r\n                        isNotPos[self.currency[1]] = True\r\n                        secondery_profit.append((self.ichi_2_strategy[1].close_data[i] -\r\n                                                 buy_price[self.currency[1]]) / buy_price[self.currency[1]])\r\n                        # writer.writerow({'Order': profit_count + loss_count, 'Price': buy_price,\r\n                        #                  'Time': order_time, 'Sell Time': klines[i][0],\r\n                        #                  'Loss/Profit': \"Profit\", 'Sell Price': close_arr[i],\r\n                        #                  'Volume': volume})\r\n                elif not self.BuySignal[i]:  # (close_arr_EB[i] < ich_b_EB[i - t_EB - 1] and close_arr_EB[i] < ich_a_EB[i - t_EB - 1]):\r\n                    self.volume = (self.volume / buy_price[self.currency[1]]) * self.ichi_2_strategy[1].close_data[i]\r\n                    balance_dict[\"Current\"] = self.volume\r\n                    buy_price[self.currency[0]] = self.ichi_2_strategy[0].close_data[i]\r\n                    isNotPos[self.currency[1]] = True\r\n                    isNotPos[self.currency[0]] = False\r\n                    if self.ichi_2_strategy[1].close_data[i] - buy_price[self.currency[1]] < 0:\r\n                        secondery_loss.append((buy_price[self.currency[1]] - self.ichi_2_strategy[1].close_data[i]) /\r\n                                              buy_price[self.currency[1]])\r\n                        secondery_missing_profit.append((buy_price[self.currency[1]] - self.ichi_2_strategy[1].close_data[i]) /\r\n                                                        buy_price[self.currency[1]])\r\n                    else:\r\n                        secondery_profit.append((self.ichi_2_strategy[1].close_data[i] - buy_price[self.currency[1]]) /\r\n                                                buy_price[self.currency[1]])\r\n                    secondery_missing_profit.append((secondery_max_price - self.ichi_2_strategy[-1].close_data[i]) / secondery_max_price)\r\n                    # print(\"Volume = \", balance_dict[\"Current\"],\r\n                    #       \"Sell_Price_\" + self.currency[1] + \"= \",\r\n                    #       self.ichi_2_strategy[1].close_data[i],\r\n                    #       \"Buy_Price_\" + self.currency[0] + \" = \",\r\n                    #       buy_price[self.currency[0]],\r\n                    #       \"Date = \", datetime.utcfromtimestamp(self.klines[0][i][0] / 1000))\r\n            elif not isNotPos[self.currency[0]]:\r\n                if self.ichi_2_strategy[0].SellStrategy(i, param[\"t\"]):\r\n                    if self.ichi_2_strategy[0].close_data[i] - buy_price[self.currency[0]] < 0:\r\n                        loss = ((buy_price[self.currency[0]] - self.ichi_2_strategy[0].close_data[i]) /\r\n                                buy_price[self.currency[0]]) * self.volume\r\n                        loss_arr.append(loss)\r\n                        balance_dict[\"Current\"] -= loss\r\n                        balance_arr.append(balance_dict[\"Current\"])\r\n                        # print(\"(Loss) Balance = \", balance_dict[\"Current\"], \"Sell_Price_\" + self.currency[0] + \" = \",\r\n                        #       self.ichi_2_strategy[0].close_data[i],\r\n                        #       \"Date = \", datetime.utcfromtimestamp(self.klines[0][i][0] / 1000))\r\n                        loss_count += 1\r\n                        profit_count_arr.append(profit_count)\r\n                        profit_count = 0\r\n                        if balance_dict[\"Min\"] > balance_dict[\"Current\"]:\r\n                            balance_dict[\"Min\"] = balance_dict[\"Current\"]\r\n                            Max_DD_arr.append((balance_dict[\"Max\"] - balance_dict[\"Min\"]) / balance_dict[\"Max\"])\r\n\r\n                        isNotPos[self.currency[0]] = True\r\n                        # writer.writerow({'Order': profit_count + loss_count, 'Price': buy_price,\r\n                        #                  'Time': order_time, 'Sell Time': klines[i][0],\r\n                        #                  'Loss/Profit': \"Loss\", 'Sell Price': close_arr[i],\r\n                        #                  'Volume': volume})\r\n                    else:\r\n                        profit = ((self.ichi_2_strategy[0].close_data[i] - buy_price[self.currency[0]]) /\r\n                                  buy_price[self.currency[0]]) * self.volume\r\n                        profit_arr.append(profit)\r\n                        balance_dict[\"Current\"] += profit\r\n                        balance_arr.append(balance_dict[\"Current\"])\r\n                        # print(\"(Profit) Balance = \", balance_dict[\"Current\"], \"Sell_Price_\" + self.currency[0] + \" = \",\r\n                        #       self.ichi_2_strategy[0].close_data[i],\r\n                        #       \"Date = \", datetime.utcfromtimestamp(self.klines[0][i][0] / 1000))\r\n                        profit_count += 1\r\n                        loss_count_arr.append(loss_count)\r\n                        loss_count = 0\r\n                        if balance_dict[\"Max\"] < balance_dict[\"Current\"]:\r\n                            balance_dict[\"Max\"] = balance_dict[\"Current\"]\r\n                            balance_dict[\"Min\"] = balance_dict[\"Current\"]\r\n                            Max_DD_arr.append((balance_dict[\"Max\"] - balance_dict[\"Min\"]) / balance_dict[\"Max\"])\r\n                        isNotPos[self.currency[0]] = True\r\n                        # writer.writerow({'Order': profit_count + loss_count, 'Price': buy_price,\r\n                        #                  'Time': order_time, 'Sell Time': klines[i][0],\r\n                        #                  'Loss/Profit': \"Profit\", 'Sell Price': close_arr[i],\r\n                        #                  'Volume': volume})\r\n                elif self.BuySignal[i]:  # ICHIMOKU_2_EB(i, 24, 48, 144, 0.01, 0.06, ICHIMOKU_fill_EB):\r\n                    self.volume = (self.volume / buy_price[self.currency[0]]) * self.ichi_2_strategy[0].close_data[i]\r\n                    balance_dict[\"Current\"] = self.volume\r\n                    buy_price[self.currency[1]] = self.ichi_2_strategy[1].close_data[i]\r\n                    isNotPos[self.currency[0]] = True\r\n                    isNotPos[self.currency[1]] = False\r\n                    secondery_max_price = self.ichi_2_strategy[2].close_data[i]\r\n                    # print(\"Volume = \", balance_dict[\"Current\"],\r\n                    #       \"Sell_Price_\" + self.currency[0] + \"= \",\r\n                    #       self.ichi_2_strategy[0].close_data[i],\r\n                    #       \"Buy_Price_\" + self.currency[1] + \" = \",\r\n                    #       buy_price[self.currency[1]],\r\n                    #       \"Date = \", datetime.utcfromtimestamp(self.klines[0][i][0] / 1000))\r\n            if secondery_max_price < self.ichi_2_strategy[2].close_data[i]:\r\n                secondery_max_price = self.ichi_2_strategy[2].close_data[i]\r\n            update_strategy = False\r\n            # th.join()\r\n        # plt.imshow(balance)\r\n\r\n        # plt.plot(balance_arr)\r\n        # plt.show()\r\n        trade_count = len(profit_arr) + len(loss_arr)\r\n        profit_count_arr.append(profit_count)\r\n        avg_profit = numpy.average(profit_count_arr)\r\n        loss_count_arr.append(loss_count)\r\n        avg_loss = numpy.average(loss_count_arr)\r\n        # print(\"Total order = \", trade_count ,\"SL =\", SL, \"RR = \", RR, \"Balance = \", balance)\r\n        if len(loss_arr) == 0:\r\n            profit_factor = sum(profit_arr)\r\n        else:\r\n            profit_factor = sum(profit_arr) / sum(loss_arr)\r\n        try:\r\n            row = [\"Algorithm_2\", second_param[\"Win1\"], second_param[\"Win2\"], second_param[\"Win3\"], second_param[\"t\"], second_param[\"a\"],\r\n                          second_param[\"b\"], balance_dict[\"Current\"] - 1000, sum(profit_arr), max(profit_arr), sum(loss_arr),\r\n                          max(loss_arr), profit_factor, len(profit_arr) / trade_count, len(loss_arr) / trade_count,\r\n                          trade_count, (balance_dict[\"Current\"] - 1000) / trade_count, max(profit_count_arr),\r\n                          avg_profit, max(loss_count_arr), avg_loss, max(Max_DD_arr) * 100, 0,sum(secondery_profit),\r\n                          sum(secondery_loss), len(secondery_profit) / (len(secondery_profit) + len(secondery_loss)),\r\n                          len(secondery_loss) / (len(secondery_profit) + len(secondery_loss)),\r\n                          len(secondery_profit) + len(secondery_loss), sum(secondery_missing_profit)]\r\n        except ZeroDivisionError:\r\n            row = [\"Algorithm_2\", second_param[\"Win1\"], second_param[\"Win2\"], second_param[\"Win3\"], second_param[\"t\"], second_param[\"a\"],\r\n                          second_param[\"b\"], balance_dict[\"Current\"] - 1000, sum(profit_arr), max(profit_arr), sum(loss_arr),\r\n                          max(loss_arr), profit_factor, 0, 0, trade_count, 0, max(profit_count_arr), avg_profit,\r\n                          max(loss_count_arr), avg_loss, max(Max_DD_arr) * 100, 0, sum(secondery_profit), sum(secondery_loss),\r\n                          0, 0, len(secondery_profit) + len(secondery_loss), sum(secondery_missing_profit)]\r\n\r\n        self.result_row.append(row)\r\n\r\n    def WriteResult(self, header, rows):\r\n        self.file.SetCSVFieldName(header)\r\n        self.file.WriteHeader()\r\n        self.file.WriteRows(rows)\r\n\r\nclass Algorithm_3(OfflineAlgorithm):\r\n    klines = {}\r\n    ichi_2_strategy = {}\r\n    Buy_Signal = {}\r\n    def __init__(self, candle, currency, currency_pair, correspond):\r\n        self.window1 = [9, 18, 24, 36]\r\n        self.window2 = [24, 48, 72]\r\n        self.window3 = [48, 96, 144]\r\n        self.t = [18, 26, 48]\r\n        self.a = [0, 0.01]\r\n        self.b = [0.04, 0.05, 0.06]\r\n        self.SL_arr = [0.025, 0.05]\r\n\r\n        # self.window1 = [18]\r\n        # self.window2 = [24]\r\n        # self.window3 = [96]\r\n        # self.t = [18]\r\n        # self.a = [0]\r\n        # self.b = [0.05]\r\n\r\n        start_time = \"1.1.2018\"\r\n        end_time = \"1.1.2020\"\r\n\r\n        self.currency = currency\r\n        self.currency_pair = currency_pair\r\n        self.correspond_currency = correspond\r\n        use_offline_data = True\r\n        for i in self.currency:\r\n            if use_offline_data:\r\n                self.klines[i] = (FileWorking.ReadKlines(\"Data\\\\\" + i + \"_1HOUR_\" + start_time + \"_\" + end_time + \".txt\"))\r\n            else:\r\n                self.klines[i] = (candle.getKlines(i, Client.KLINE_INTERVAL_1HOUR, \"1 Jan, 2018\", \"1 Jan, 2020\"))\r\n                FileWorking.WriteKlines(self.klines[i], \"Data\\\\\" + i + \"_1HOUR_\" + start_time + \"_\" + end_time + \".txt\")\r\n            candle.unpackCandle(self.klines[i])\r\n            high = pd.Series(candle.high)\r\n            low = pd.Series(candle.low)\r\n\r\n            self.close_data = candle.close\r\n\r\n            self.ichi_2_strategy[i] = (ICHIMOKU_2_Strategy(high, low, self.close_data))\r\n\r\n        for i in self.currency_pair:\r\n            if use_offline_data:\r\n                self.klines[i] = (FileWorking.ReadKlines(\"Data\\\\\" + i + \"_1HOUR_\" + start_time + \"_\" + end_time + \".txt\"))\r\n            else:\r\n                self.klines[i] = (candle.getKlines(i, Client.KLINE_INTERVAL_1HOUR, \"1 Jan, 2018\", \"1 Jan, 2020\"))\r\n                FileWorking.WriteKlines(self.klines[i], \"Data\\\\\" + i + \"_1HOUR_\" + start_time + \"_\" + end_time + \".txt\")\r\n            candle.unpackCandle(self.klines[i])\r\n            high = pd.Series(candle.high)\r\n            low = pd.Series(candle.low)\r\n\r\n            self.close_data = candle.close\r\n\r\n            self.ichi_2_strategy[i] = (ICHIMOKU_2_Strategy(high, low, self.close_data))\r\n\r\n        self.file = CSVFiles(\"Strategy_2-2018_2020-ETHBNBBTC.csv\")\r\n        self.result_row = []\r\n        self.Buy_Signal = {}\r\n\r\n    def CreateThread(self, main_param, second_param):\r\n        self.th_sec = {}\r\n        try:\r\n            for i in self.currency_pair:\r\n                self.th_sec[i] = threading.Thread(target=self.SecondThread, args=(second_param, i,))\r\n                self.th_sec[i].start()\r\n            time.sleep(1)\r\n            self.th_main = threading.Thread(target=self.MainThread, args=(main_param, second_param, ))\r\n            self.th_main.start()\r\n        except:\r\n            print(\"Error: unable to start thread\")\r\n\r\n    def RunAlgorithm(self):\r\n        fieldnames = ['Strategy', 'Win1', 'Win2', 'Win3', 'T', 'A', 'B', 'Total Net Profit',\r\n                      'Gross Profit', 'Max Profit', 'Gross Loss', 'Max Loss', 'Profit Factor',\r\n                      'Profit Trade (%)', 'Loss Trade (%)', 'Total Trade', 'Expected Payoff', 'Max Consecutive Wins',\r\n                      'Avg Consecutive Wins', 'Max Consecutive Loss', 'Avg Consecutive Loss',\r\n                      'Max Draw Down (%)', 'Max Draw Down (Time)']\r\n\r\n        main_thread_param = {\"Win1\": 36, \"Win2\": 48, \"Win3\": 144, \"t\": 18, \"a\": 0, \"b\": 0.04}\r\n        for win1 in self.window1:\r\n            for win2 in self.window2:\r\n                for win3 in self.window3:\r\n                    for t in self.t:\r\n                        print(win1, \" \", win2, \" \", win3, \" \", t, \" \")\r\n                        for a in self.a:\r\n                            for b in self.b:\r\n                                second_thread_param = {\"Win1\": win1, \"Win2\": win2, \"Win3\": win3, \"t\": t, \"a\": a, \"b\": b}\r\n                                self.CreateThread(main_thread_param, second_thread_param)\r\n                                time.sleep(10)\r\n                                self.th_main.join()\r\n                                for i in self.currency_pair:\r\n                                    self.th_sec[i].join()\r\n        self.WriteResult(fieldnames, self.result_row)\r\n\r\n    def SecondThread(self, param, currency):\r\n        self.Buy_Signal[currency] = [False] * len(self.klines[currency])\r\n        update_strategy = True\r\n        isNotPos = True\r\n        j = 1\r\n        while j < len(self.klines[currency]) - 1:\r\n            if update_strategy:\r\n                self.ichi_2_strategy[currency].ComputeIchimoku_A(param[\"Win1\"], param[\"Win2\"])\r\n                self.ichi_2_strategy[currency].ComputeIchimoku_B(param[\"Win2\"], param[\"Win3\"])\r\n                self.ichi_2_strategy[currency].ComputeIchimoku_Base_Line(param[\"Win1\"], param[\"Win2\"])\r\n                self.ichi_2_strategy[currency].ComputeIchimoku_Conversion_Line(param[\"Win1\"], param[\"Win2\"])\r\n            if self.ichi_2_strategy[currency].BuyStrategy(j, param[\"t\"], param[\"a\"], param[\"b\"]) and isNotPos:\r\n                self.Buy_Signal[currency][j] = True\r\n                isNotPos = False\r\n            elif not isNotPos:\r\n                if j - param[\"t\"] - 1 > 0:\r\n                    if self.ichi_2_strategy[currency].SellStrategy(j, param[\"t\"]):\r\n                        self.Buy_Signal[currency][j] = False\r\n                        isNotPos = True\r\n                    else:\r\n                        self.Buy_Signal[currency][j] = True\r\n            update_strategy = False\r\n            j += 1\r\n\r\n    def MainThread(self, param, second_param):\r\n        update_strategy = True\r\n        balance_dict = {\"Current\": 1000, \"Max\": 1000, \"Min\": 1000, \"Available\": 1000}\r\n        isNotPos = {}\r\n        for i in self.currency:\r\n            isNotPos[i] = True\r\n        balance_arr = []\r\n        buy_price = {}\r\n        Max_DD_arr = []\r\n        profit_arr = []\r\n        loss_arr = []\r\n        profit_count = 0\r\n        profit_count_arr = []\r\n        loss_count = 0\r\n        loss_count_arr = []\r\n        True_Buy_Signal = []\r\n        order_count = 0\r\n        for i in range(1, len(self.klines[self.currency[0]]) - 1):\r\n            if update_strategy:\r\n                self.ichi_2_strategy[self.currency[0]].ComputeIchimoku_A(param[\"Win1\"], param[\"Win2\"])\r\n                self.ichi_2_strategy[self.currency[0]].ComputeIchimoku_B(param[\"Win2\"], param[\"Win3\"])\r\n                self.ichi_2_strategy[self.currency[0]].ComputeIchimoku_Base_Line(param[\"Win1\"], param[\"Win2\"])\r\n                self.ichi_2_strategy[self.currency[0]].ComputeIchimoku_Conversion_Line(param[\"Win1\"], param[\"Win2\"])\r\n            if self.ichi_2_strategy[self.currency[0]].BuyStrategy(i, param[\"t\"], param[\"a\"], param[\"b\"]) \\\r\n                    and self.CheckAllPos(isNotPos):\r\n                True_Buy_Signal = self.FindBuySignal(self.Buy_Signal, i)\r\n                if len(True_Buy_Signal) != 0:\r\n                    for j in True_Buy_Signal:\r\n                        buy_price[self.correspond_currency[j]] = \\\r\n                        self.ichi_2_strategy[self.correspond_currency[j]].close_data[i]\r\n                        isNotPos[self.correspond_currency[j]] = False\r\n                        # print(\"Order \", order_count, \" Buy_Price_\" + self.correspond_currency[j] + \" = \",\r\n                        #       buy_price[self.correspond_currency[j]], \" Volume = \",\r\n                        #       balance_dict[\"Current\"] / len(True_Buy_Signal), \" Date = \",\r\n                        #       datetime.utcfromtimestamp(self.klines[self.currency[0]][i][0] / 1000))\r\n                    self.volume = balance_dict[\"Current\"] / len(True_Buy_Signal)\r\n                else:\r\n                    buy_price[self.currency[0]] = self.ichi_2_strategy[self.currency[0]].close_data[i]\r\n                    isNotPos[self.currency[0]] = False\r\n                    self.volume = balance_dict[\"Current\"]\r\n                    # print(\"Order \", order_count, \" Buy_Price_\" + self.currency[0] + \" = \",\r\n                    #       buy_price[self.currency[0]], \" Volume = \", self.volume,\r\n                    #       \"Date = \", datetime.utcfromtimestamp(self.klines[self.currency[0]][i][0] / 1000))\r\n                balance_dict[\"Available\"] = 0\r\n                i += 1\r\n            if not isNotPos[self.currency[0]]:\r\n                if self.ichi_2_strategy[self.currency[0]].SellStrategy(i, param[\"t\"]):\r\n                    if self.ichi_2_strategy[self.currency[0]].close_data[i] - buy_price[self.currency[0]] < 0:\r\n                        loss = ((buy_price[self.currency[0]] - self.ichi_2_strategy[self.currency[0]].close_data[i]) /\r\n                                buy_price[self.currency[0]]) * self.volume\r\n                        loss_arr.append(loss)\r\n                        balance_dict[\"Current\"] -= loss\r\n                        balance_arr.append(balance_dict[\"Current\"])\r\n                        # print(\"(Loss) Balance = \", balance_dict[\"Current\"], \"Sell_Price_\" + self.currency[0] + \" = \",\r\n                        #       self.ichi_2_strategy[self.currency[0]].close_data[i],\r\n                        #       \"Date = \", datetime.utcfromtimestamp(self.klines[self.currency[0]][i][0] / 1000))\r\n                        loss_count += 1\r\n                        profit_count_arr.append(profit_count)\r\n                        profit_count = 0\r\n                        isNotPos[self.currency[0]] = True\r\n                        # writer.writerow({'Order': profit_count + loss_count, 'Price': buy_price,\r\n                        #                  'Time': order_time, 'Sell Time': klines[i][0],\r\n                        #                  'Loss/Profit': \"Loss\", 'Sell Price': close_arr[i],\r\n                        #                  'Volume': volume})\r\n                    else:\r\n                        profit = ((self.ichi_2_strategy[self.currency[0]].close_data[i] - buy_price[self.currency[0]]) /\r\n                                  buy_price[self.currency[0]]) * self.volume\r\n                        profit_arr.append(profit)\r\n                        balance_dict[\"Current\"] += profit\r\n                        balance_arr.append(balance_dict[\"Current\"])\r\n                        # print(\"(Profit) Balance = \", balance_dict[\"Current\"], \"Sell_Price_\" + self.currency[0] + \" = \",\r\n                        #       self.ichi_2_strategy[self.currency[0]].close_data[i],\r\n                        #       \"Date = \", datetime.utcfromtimestamp(self.klines[self.currency[0]][i][0] / 1000))\r\n                        profit_count += 1\r\n                        loss_count_arr.append(loss_count)\r\n                        loss_count = 0\r\n                        isNotPos[self.currency[0]] = True\r\n                        # writer.writerow({'Order': profit_count + loss_count, 'Price': buy_price,\r\n                        #                  'Time': order_time, 'Sell Time': klines[i][0],\r\n                        #                  'Loss/Profit': \"Profit\", 'Sell Price': close_arr[i],\r\n                        #                  'Volume': volume})\r\n                    order_count += 1\r\n                else:\r\n                    True_Buy_Signal = self.FindBuySignal(self.Buy_Signal, i)\r\n                    if len(True_Buy_Signal) != 0:\r\n                        balance_dict[\"Available\"] = (self.volume / buy_price[self.currency[0]]) * \\\r\n                                                    self.ichi_2_strategy[self.currency[0]].close_data[i]\r\n                        for j in True_Buy_Signal:\r\n                            buy_price[self.correspond_currency[j]] = \\\r\n                            self.ichi_2_strategy[self.correspond_currency[j]].close_data[i]\r\n                            isNotPos[self.correspond_currency[j]] = False\r\n                            # print(\"Volume = \", balance_dict[\"Available\"] / len(True_Buy_Signal),\r\n                            #       \"Sell_Price_\" + self.currency[0] + \"= \",\r\n                            #       self.ichi_2_strategy[self.currency[0]].close_data[i],\r\n                            #       \"Buy_Price_\" + self.correspond_currency[j] + \" = \",\r\n                            #       buy_price[self.correspond_currency[j]],\r\n                            #       \"Date = \", datetime.utcfromtimestamp(self.klines[self.currency[0]][i][0] / 1000))\r\n                        self.volume = balance_dict[\"Available\"] / len(True_Buy_Signal)\r\n                        balance_dict[\"Current\"] = balance_dict[\"Available\"]\r\n                        balance_dict[\"Available\"] = 0\r\n                        isNotPos[self.currency[0]] = True\r\n            elif not self.CheckAllPos(isNotPos):\r\n                if self.ichi_2_strategy[self.currency[0]].SellStrategy(i, param[\"t\"]):\r\n                    balance_dict[\"Available\"] = (self.volume * len(True_Buy_Signal))\r\n                    for j in True_Buy_Signal:\r\n                        if self.ichi_2_strategy[self.correspond_currency[j]].close_data[i] - \\\r\n                                buy_price[self.correspond_currency[j]] < 0:\r\n                            loss = ((buy_price[self.correspond_currency[j]] -\r\n                                     self.ichi_2_strategy[self.correspond_currency[j]].close_data[i]) /\r\n                                    buy_price[self.correspond_currency[j]]) * self.volume\r\n                            loss_arr.append(loss)\r\n                            balance_dict[\"Available\"] -= loss\r\n                            loss_count += 1\r\n                            profit_count_arr.append(profit_count)\r\n                            profit_count = 0\r\n                            # print(\"(Loss) Balance = \", balance_dict[\"Current\"],\r\n                            #       \"Sell_Price_\" + self.correspond_currency[j] + \" = \",\r\n                            #       self.ichi_2_strategy[self.correspond_currency[j]].close_data[i], \"Date = \",\r\n                            #       datetime.utcfromtimestamp(self.klines[self.currency[0]][i][0] / 1000))\r\n                        else:\r\n                            profit = ((self.ichi_2_strategy[self.correspond_currency[j]].close_data[i] -\r\n                                       buy_price[self.correspond_currency[j]]) / buy_price[\r\n                                          self.correspond_currency[j]]) * self.volume\r\n                            profit_arr.append(profit)\r\n                            balance_dict[\"Available\"] += profit\r\n                            profit_count += 1\r\n                            loss_count_arr.append(loss_count)\r\n                            loss_count = 0\r\n                            # print(\"(Profit) Balance = \", balance_dict[\"Current\"],\r\n                            #       \"Sell_Price_\" + self.correspond_currency[j] + \" = \",\r\n                            #       self.ichi_2_strategy[self.correspond_currency[j]].close_data[i], \"Date = \",\r\n                            #       datetime.utcfromtimestamp(self.klines[self.currency[0]][i][0] / 1000))\r\n                        balance_dict[\"Current\"] = balance_dict[\"Available\"]\r\n                        balance_arr.append(balance_dict[\"Current\"])\r\n                        isNotPos[self.correspond_currency[j]] = True\r\n                    order_count += 1\r\n                elif len(True_Buy_Signal) != 0:\r\n                    Sell_Signal_True = self.FindSellSignal(self.Buy_Signal, True_Buy_Signal, i)\r\n                    Buy_Signal_New = self.FindBuySignal(self.Buy_Signal, i)\r\n                    if len(Sell_Signal_True) != 0:\r\n                        for j in Sell_Signal_True:\r\n                            balance_dict[\"Available\"] += (self.volume / buy_price[self.correspond_currency[j]]) * \\\r\n                                                        self.ichi_2_strategy[self.correspond_currency[j]].close_data[i]\r\n                            isNotPos[self.correspond_currency[j]] = True\r\n                        if len(Sell_Signal_True) == len(True_Buy_Signal):\r\n                            buy_price[self.currency[0]] = self.ichi_2_strategy[self.currency[0]].close_data[i]\r\n                            isNotPos[self.currency[0]] = False\r\n                            self.volume = balance_dict[\"Available\"]\r\n                            balance_dict[\"Current\"] = balance_dict[\"Available\"]\r\n                            balance_dict[\"Available\"] = 0\r\n                            # print(\"Volume = \", self.volume, \"Sell_Price_\" + self.correspond_currency[j] + \"= \",\r\n                            #       self.ichi_2_strategy[self.correspond_currency[j]].close_data[i],\r\n                            #       \"Buy_Price_\" + self.currency[0] + \" = \", buy_price[self.currency[0]],\r\n                            #       \"Date = \", datetime.utcfromtimestamp(self.klines[self.currency[0]][i][0] / 1000))\r\n                        else:\r\n                            True_Buy_Signal = self.FindBuySignal(self.Buy_Signal, i)\r\n                            if len(True_Buy_Signal) != 0:\r\n                                for j in True_Buy_Signal:\r\n                                    balance_dict[\"Available\"] += (self.volume / buy_price[self.correspond_currency[j]])\\\r\n                                                                 * self.ichi_2_strategy[self.correspond_currency[j]].close_data[i]\r\n                                    buy_price[self.correspond_currency[j]] = \\\r\n                                    self.ichi_2_strategy[self.correspond_currency[j]].close_data[i]\r\n                                    # print(\"Volume = \", self.volume,\r\n                                    #       \"Sell_Price\",\r\n                                    #       \"Buy_Price_\" + self.correspond_currency[j] + \" = \",\r\n                                    #       buy_price[self.correspond_currency[j]],\r\n                                    #       \"Date = \", datetime.utcfromtimestamp(self.klines[self.currency[0]][i][0] / 1000))\r\n                                    isNotPos[self.correspond_currency[j]] = False\r\n                                self.volume = balance_dict[\"Available\"] / len(True_Buy_Signal)\r\n                                balance_dict[\"Current\"] = balance_dict[\"Available\"]\r\n                                balance_dict[\"Available\"] = 0\r\n                    elif len(True_Buy_Signal) != len(Buy_Signal_New) and len(Buy_Signal_New) != 0:\r\n                        Buy_Signal_New = self.FindDiffrentBuySignal(True_Buy_Signal, Buy_Signal_New)\r\n                        for j in True_Buy_Signal:\r\n                            balance_dict[\"Available\"] += (self.volume / buy_price[self.correspond_currency[j]]) * \\\r\n                                                         self.ichi_2_strategy[self.correspond_currency[j]].close_data[i]\r\n                            buy_price[self.correspond_currency[j]] = self.ichi_2_strategy[self.correspond_currency[j]].close_data[i]\r\n                        for k in Buy_Signal_New:\r\n                            buy_price[self.correspond_currency[k]] = self.ichi_2_strategy[self.correspond_currency[k]].close_data[i]\r\n                            isNotPos[self.correspond_currency[j]] = False\r\n                        self.volume = balance_dict[\"Available\"] / (len(Buy_Signal_New) + len(True_Buy_Signal))\r\n                        balance_dict[\"Current\"] = balance_dict[\"Available\"]\r\n                        balance_dict[\"Available\"] = 0\r\n                        # print(\"Volume = \", self.volume,\r\n                        #       \"Sell_Price_\" + self.correspond_currency[j] + \"= \",\r\n                        #       self.ichi_2_strategy[self.correspond_currency[j]].close_data[i],\r\n                        #       \"Buy_Price_\" + self.correspond_currency[Buy_Signal_New[0]] + \" = \",\r\n                        #       buy_price[self.correspond_currency[k]], \"Date = \",\r\n                        #       datetime.utcfromtimestamp(self.klines[self.currency[0]][i][0] / 1000))\r\n                        True_Buy_Signal.extend(Buy_Signal_New)\r\n            update_strategy = False\r\n        trade_count = len(profit_arr) + len(loss_arr)\r\n        profit_count_arr.append(profit_count)\r\n        avg_profit = numpy.average(profit_count_arr)\r\n        loss_count_arr.append(loss_count)\r\n        avg_loss = numpy.average(loss_count_arr)\r\n        # print(\"Total order = \", trade_count ,\"SL =\", SL, \"RR = \", RR, \"Balance = \", balance)\r\n        if len(loss_arr) == 0:\r\n            profit_factor = sum(profit_arr)\r\n        else:\r\n            profit_factor = sum(profit_arr) / sum(loss_arr)\r\n        try:\r\n            row = [\"Algorithm_2\", second_param[\"Win1\"], second_param[\"Win2\"], second_param[\"Win3\"], second_param[\"t\"], second_param[\"a\"],\r\n                          second_param[\"b\"], balance_dict[\"Current\"] - 1000, sum(profit_arr), max(profit_arr), sum(loss_arr),\r\n                          max(loss_arr), profit_factor, len(profit_arr) / trade_count, len(loss_arr) / trade_count,\r\n                          trade_count, (balance_dict[\"Current\"] - 1000) / trade_count, max(profit_count_arr),\r\n                          avg_profit, max(loss_count_arr), avg_loss, 0, 0]\r\n        except ZeroDivisionError:\r\n            row = [\"Algorithm_2\", second_param[\"Win1\"], second_param[\"Win2\"], second_param[\"Win3\"], second_param[\"t\"], second_param[\"a\"],\r\n                          second_param[\"b\"], balance_dict[\"Current\"] - 1000, sum(profit_arr), max(profit_arr), sum(loss_arr),\r\n                          max(loss_arr), profit_factor, 0, 0, trade_count, 0, max(profit_count_arr), avg_profit,\r\n                          max(loss_count_arr), avg_loss, 0, 0]\r\n\r\n        self.result_row.append(row)\r\n        print(row)\r\n\r\n    def CheckAllPos(self, pos):\r\n        for _,i in pos.items():\r\n            if not i:\r\n                return False\r\n        return True\r\n\r\n    def FindBuySignal(self, buy_signal, i):\r\n        Buy_Signal_True = []\r\n        for currency, yes in buy_signal.items():  # for name, age in dictionary.iteritems():  (for Python 2.x)\r\n            if yes[i] == True:\r\n                Buy_Signal_True.append(currency)\r\n        return Buy_Signal_True\r\n\r\n    def FindSellSignal(self, buy_signal, buy_currency, i):\r\n        dict = {key: buy_signal[key] for key in buy_currency}\r\n        Sell_Signal_True = []\r\n        for currency, yes in dict.items():  # for name, age in dictionary.iteritems():  (for Python 2.x)\r\n            if yes[i] == False:\r\n                Sell_Signal_True.append(currency)\r\n        return Sell_Signal_True\r\n\r\n    def FindDiffrentBuySignal(self, source_1, source_2):\r\n        return list(set(source_2) - set(source_1))\r\n\r\n    def WriteResult(self, header, rows):\r\n        self.file.SetCSVFieldName(header)\r\n        self.file.WriteHeader()\r\n        self.file.WriteRows(rows)\r\n\r\nclass Algorithm_4(Algorithm_3):\r\n    strategy = {}\r\n    def __init__(self, candle, currency):\r\n\r\n        start_time = date(2020, 1, 1)\r\n        end_time = date(2021, 1, 1)\r\n\r\n        self.currency = currency\r\n        self.currency_pair = []\r\n        for i in self.currency[:-1]:\r\n            self.currency_pair.append(i+self.currency[-1])\r\n        self.currency_pair_secondery = []\r\n        for i in self.currency[1:-1]:\r\n            self.currency_pair_secondery.append(i+self.currency[0])\r\n\r\n        self.correspond_currency = {}\r\n        for i, item in enumerate(self.currency_pair_secondery):\r\n            self.correspond_currency[self.currency[i+1]] = self.currency_pair[i+1]\r\n            self.correspond_currency[self.currency_pair[i+1]] = item\r\n\r\n        use_offline_data = True\r\n        for i in self.currency_pair + self.currency_pair_secondery:\r\n            if use_offline_data:\r\n                self.klines[i] = (FileWorking.ReadKlines(\"Data\\\\\" + i + \"_1HOUR_\" + start_time.isoformat() + \"_\" +\r\n                                                         end_time.isoformat() + \".txt\"))\r\n            else:\r\n                self.klines[i] = (candle.getKlines(i, Client.KLINE_INTERVAL_1HOUR, start_time.strftime(\"%d %b, %Y\"),\r\n                                                   end_time.strftime(\"%d %b, %Y\")))\r\n                FileWorking.WriteKlines(self.klines[i], \"Data\\\\\" + i + \"_1HOUR_\" + start_time.isoformat() + \"_\" +\r\n                                        end_time.isoformat() + \".txt\")\r\n            candle.unpackCandle(self.klines[i])\r\n            high = pd.Series(candle.high)\r\n            low = pd.Series(candle.low)\r\n\r\n            self.close_data = candle.close\r\n\r\n            self.strategy[i] = (ICHIMOKU_2_Strategy(high, low, self.close_data))\r\n        self.file = CSVFiles(\"Algorithm_7-\" + start_time.strftime(\"%Y-%m-%d_\") + end_time.strftime(\"%Y-%m-%d_\") +\r\n                             self.currency_pair[0] + \".csv\")\r\n        self.result_row = []\r\n        self.Buy_Signal = {}\r\n        self.param = {}\r\n        self.BS = {}\r\n\r\n    def SetAlgorithmParam(self, currency_pair, window1, window2, window3, t, a, b):\r\n        p = {\"Win1\": window1, \"Win2\": window2, \"Win3\": window3, \"t\": t, \"a\": a, \"b\": b}\r\n        self.param[currency_pair] = p\r\n\r\n    def Run(self):\r\n        self.CreateThread(self.param)\r\n        for i in self.currency_pair + self.currency_pair_secondery:\r\n            self.th[i].join()\r\n        self.ComputeBuySignal()\r\n        self.RunAlgorithm()\r\n\r\n    def LogResult(self):\r\n        fieldnames = ['Strategy', 'Win1', 'Win2', 'Win3', 'T', 'A', 'Total Net Profit',\r\n                      'Gross Profit', 'Max Profit', 'Gross Loss', 'Max Loss', 'Profit Factor',\r\n                      'Profit Trade (%)', 'Loss Trade (%)', 'Total Trade', 'Expected Payoff', 'Max Consecutive Wins',\r\n                      'Avg Consecutive Wins', 'Max Consecutive Loss', 'Avg Consecutive Loss',\r\n                      'Max Draw Down (%)', 'Max Draw Down (Time)']\r\n\r\n        # fieldnames = [\"Win1\", \"Win2\", \"Win3\", \"t\", \"a\"]\r\n        # fieldnames = fieldnames + [\"Order\" + str(k + 1) for k in range(0, 200)]\r\n        self.WriteResult(fieldnames, self.result_row)\r\n\r\n    def CreateThread(self, param):\r\n        self.th = {}\r\n        try:\r\n            for i in self.currency_pair + self.currency_pair_secondery:\r\n                self.th[i] = threading.Thread(target=self.BuySignalThread, args=(param, i,))\r\n                self.th[i].start()\r\n        except:\r\n            print(\"Error: unable to start thread\")\r\n\r\n    def BuySignalThread(self, param, currency):\r\n        self.BS[currency] = [False] * len(self.klines[currency])\r\n        update_strategy = True\r\n        isNotPos = True\r\n        j = 1\r\n        while j < len(self.klines[currency]) - 1:\r\n            if update_strategy:\r\n                self.strategy[currency].ComputeIchimoku_A(param[currency][\"Win1\"], param[currency][\"Win2\"])\r\n                self.strategy[currency].ComputeIchimoku_B(param[currency][\"Win2\"], param[currency][\"Win3\"])\r\n                self.strategy[currency].ComputeIchimoku_Base_Line(param[currency][\"Win1\"], param[currency][\"Win2\"])\r\n                self.strategy[currency].ComputeIchimoku_Conversion_Line(param[currency][\"Win1\"], param[currency][\"Win2\"])\r\n            if self.strategy[currency].BuyStrategy(j, param[currency][\"t\"], param[currency][\"a\"], param[currency][\"b\"]) and isNotPos:\r\n                self.BS[currency][j] = True\r\n                isNotPos = False\r\n            elif not isNotPos:\r\n                if j - param[currency][\"t\"] - 1 > 0:\r\n                    if self.strategy[currency].SellStrategy(j, param[currency][\"t\"]):\r\n                        self.BS[currency][j] = False\r\n                        isNotPos = True\r\n                    else:\r\n                        self.BS[currency][j] = True\r\n            update_strategy = False\r\n            j += 1\r\n\r\n    def ComputeBuySignal(self):\r\n        self.Buy_Signal = []\r\n        BS = {}\r\n        for i in range(0, len(self.BS[self.currency_pair[0]])):\r\n            b = self.FindBuySignal(self.BS, i)\r\n            if self.currency_pair[0] in b:\r\n                BS[self.currency[0]] = 1\r\n            else:\r\n                BS[self.currency[0]] = 0\r\n            for j in self.currency[1:-1]:\r\n                matching = [s for s in b if j in s]\r\n                if len(matching) > 1:\r\n                    BS[j] = 2\r\n                elif len(matching) == 1 and matching[0] != j+self.currency[-1]:\r\n                    BS[j] = 1\r\n                else:\r\n                    BS[j] = 0\r\n            self.Buy_Signal.append(BS.copy())\r\n\r\n    def FindKeyFromCurrency(self, currency_pair, currency):\r\n        return [s for s in currency_pair if currency in s]\r\n\r\n    def CheckAction(self, iter):\r\n        Order = {\"Buy\": [], \"Sell\": [], \"SellNotAll\": []}\r\n        zero_buy_signal = self.GetSpecificBuySignal(iter, 0)\r\n        one_buy_signal = self.GetSpecificBuySignal(iter, 1)\r\n        two_buy_signal = self.GetSpecificBuySignal(iter, 2)\r\n        pos = self.CheckTrueIsPos()\r\n        if len(pos) == 0 and self.currency[0] in one_buy_signal and len(one_buy_signal + two_buy_signal) == 1:#1\r\n            Order[\"Buy\"] = self.FindKeyFromCurrency(self.currency_pair, self.currency[0])\r\n            self.isPos[self.currency[0]] = True\r\n        elif self.currency[0] in pos:#4 6 8\r\n            for i in two_buy_signal:\r\n                Order[\"Buy\"] += self.FindKeyFromCurrency(self.currency_pair_secondery, i)\r\n                self.isPos[i] = True\r\n            if self.currency[0] in one_buy_signal:\r\n                for i in one_buy_signal:\r\n                    if i != self.currency[0]:\r\n                        Order[\"Buy\"] += self.FindKeyFromCurrency(self.currency_pair_secondery, i)\r\n                        self.isPos[i] = True\r\n            elif self.currency[0] in zero_buy_signal and len(two_buy_signal) == 0:\r\n                Order[\"Sell\"] = self.FindKeyFromCurrency(self.currency_pair, self.currency[0])\r\n                self.isPos[self.currency[0]] = False\r\n            if len(Order[\"Buy\"]) > 0:\r\n                self.isPos[self.currency[0]] = False\r\n            return Order\r\n        elif len(pos) > 0 and self.currency[0] not in pos:\r\n            if self.currency[0] in one_buy_signal and len(one_buy_signal + two_buy_signal) == 1:#2\r\n                for i in pos:\r\n                    Order[\"Sell\"] += self.FindKeyFromCurrency(self.currency_pair_secondery, i)\r\n                    self.isPos[i] = False\r\n                self.isPos[self.currency[0]] = True\r\n            elif self.CheckPosInBuySignal(pos, zero_buy_signal) or \\\r\n                    (self.currency[0] in zero_buy_signal and self.CheckPosInBuySignal(pos, one_buy_signal)):#5 7\r\n                currency = self.currency_pair_secondery if self.currency[0] in one_buy_signal else self.currency_pair\r\n                for i in pos:\r\n                    if i in zero_buy_signal or (self.currency[0] in zero_buy_signal and i in one_buy_signal):\r\n                        Order[\"Sell\"] += self.FindKeyFromCurrency(currency, i)\r\n                        self.isPos[i] = False\r\n                for i in two_buy_signal:\r\n                    Order[\"Buy\"] += self.FindKeyFromCurrency(currency, i)\r\n                    self.isPos[i] = True\r\n                if self.currency[0] in one_buy_signal:\r\n                    for i in one_buy_signal:\r\n                        if i != self.currency[0]:\r\n                            Order[\"Buy\"] += self.FindKeyFromCurrency(currency, i)\r\n                            self.isPos[i] = True\r\n        if (len(two_buy_signal) > 0 or len(one_buy_signal) > 1) and \\\r\n                self.CheckNewBuy(pos, one_buy_signal, two_buy_signal):#3\r\n            currency = self.currency_pair_secondery if len(pos) > 0 and self.currency[0] in one_buy_signal\\\r\n                else self.currency_pair\r\n            for i in two_buy_signal:\r\n                if i in pos:\r\n                    Order[\"SellNotAll\"] += self.FindKeyFromCurrency(currency, i)\r\n                else:\r\n                    Order[\"Buy\"] += self.FindKeyFromCurrency(currency, i)\r\n                    self.isPos[i] = True\r\n            if self.currency[0] in one_buy_signal:\r\n                for i in one_buy_signal:\r\n                    if i in pos and i != self.currency[0]:\r\n                        Order[\"SellNotAll\"] += self.FindKeyFromCurrency(currency, i)\r\n                    elif i != self.currency[0]:\r\n                        Order[\"Buy\"] += self.FindKeyFromCurrency(currency, i)\r\n                        self.isPos[i] = True\r\n\r\n        return Order\r\n\r\n    def GetSpecificBuySignal(self, i, state):\r\n        return [c for c, s in self.Buy_Signal[i].items() if s == state]\r\n\r\n    def CheckTrueIsPos(self):\r\n        return [k for k, s in self.isPos.items() if s]\r\n\r\n    def CheckPosInBuySignal(self, pos, buy_signal_list):\r\n        for i in pos:\r\n            if i in buy_signal_list:\r\n                return True\r\n        return False\r\n\r\n    def CheckNewBuy(self, pos, one_buy_signal, two_buy_signal):\r\n        for i in two_buy_signal:\r\n            if i not in pos:\r\n                return True\r\n        for i in one_buy_signal:\r\n            if self.currency[0] in one_buy_signal and i != self.currency[0]:\r\n                if i not in pos:\r\n                    return True\r\n        return False\r\n\r\n    def RunAlgorithm(self):\r\n        balance = {\"Current\": 1000, \"Max\": 1000, \"Min\": 1000, \"Available\": 1000, \"All\": []}\r\n        self.isPos = {}\r\n        valume = {}\r\n        buy_price = {}\r\n        for i in self.currency:\r\n            self.isPos[i] = False\r\n            valume[i] = 0\r\n            buy_price[i] = 0\r\n        profit = []\r\n        loss = []\r\n        isProfitOrLoss = []\r\n        profit_percents = []\r\n        loss_percents = []\r\n        buy_count = 0\r\n        sell_count = 0\r\n        Max_DD_arr = []\r\n        for i in range(1, len(self.klines[self.currency_pair[0]]) - 1):\r\n            action = self.CheckAction(i)\r\n            for j in action[\"Sell\"]:\r\n                sell_count += 1\r\n                if self.currency[-1] in j:\r\n                    d = self.strategy[j].close_data[i] - buy_price[j[:3]]\r\n                    balance[\"Available\"] += valume[j[:3]] * self.strategy[j].close_data[i]\r\n                else:\r\n                    d = self.strategy[j[:3] + self.currency[-1]].close_data[i] - buy_price[j[:3]]\r\n                    balance[\"Available\"] += valume[j[:3]] * self.strategy[j[:3] + self.currency[-1]].close_data[i]\r\n\r\n                if d > 0:\r\n                    profit.append(d * valume[j[:3]])\r\n                    profit_percents.append(d / buy_price[j[:3]])\r\n                    balance[\"Current\"] += profit[-1]\r\n                    balance[\"All\"].append(balance[\"Current\"])\r\n                    # Max_DD_arr.append((max(balance[\"Current\"]) - min(balance[\"Current\"])) / max(balance[\"Current\"]))\r\n                    valume[j[:3]] = 0\r\n                    isProfitOrLoss.append(1)\r\n                else:\r\n                    loss.append(abs(d) * valume[j[:3]])\r\n                    loss_percents.append(abs(d) / buy_price[j[:3]])\r\n                    valume[j[:3]] = 0\r\n                    balance[\"Current\"] -= loss[-1]\r\n                    balance[\"All\"].append(balance[\"Current\"])\r\n                    # Max_DD_arr.append((max(balance[\"Current\"]) - min(balance[\"Current\"])) / max(balance[\"Current\"]))\r\n                    isProfitOrLoss.append(0)\r\n\r\n                if valume[self.currency[0]] == 0 and len(action[\"Buy\"]) == 0:\r\n                    if j[3:] == self.currency[0]:\r\n                        buy_price[self.currency[0]] = self.strategy[self.currency_pair[0]].close_data[i]\r\n                        valume[self.currency[0]] = balance[\"Available\"] / buy_price[self.currency[0]]\r\n                        balance[\"Available\"] = 0\r\n\r\n            for j in action[\"SellNotAll\"]:\r\n                sell_count +=1\r\n                if self.currency[-1] in j:\r\n                    d = self.strategy[j].close_data[i] - buy_price[j[:3]]\r\n                    balance[\"Available\"] += (valume[j[:3]] / len(action[\"SellNotAll\"] + action[\"Buy\"])) *\\\r\n                                            len(action[\"Buy\"]) * self.strategy[j].close_data[i]\r\n                else:\r\n                    d = self.strategy[j[:3] + self.currency[-1]].close_data[i] - buy_price[j[:3]]\r\n                    balance[\"Available\"] += (valume[j[:3]] / len(action[\"SellNotAll\"] + action[\"Buy\"])) *\\\r\n                                            len(action[\"Buy\"]) * \\\r\n                                            self.strategy[j[:3] + self.currency[-1]].close_data[i]\r\n                if d > 0:\r\n                    profit.append(d * (valume[j[:3]] / len(action[\"SellNotAll\"] + action[\"Buy\"])) * len(action[\"Buy\"]))\r\n                    profit_percents.append(d / buy_price[j[:3]])\r\n                    valume[j[:3]] -= (valume[j[:3]] / len(action[\"SellNotAll\"] + action[\"Buy\"])) * len(action[\"Buy\"])\r\n                    balance[\"Current\"] += profit[-1]\r\n                    # Max_DD_arr.append((max(balance[\"Current\"]) - min(balance[\"Current\"])) / max(balance[\"Current\"]))\r\n                    isProfitOrLoss.append(1)\r\n                else:\r\n                    loss.append(abs(d) * (valume[j[:3]] / len(action[\"SellNotAll\"] + action[\"Buy\"])) * len(action[\"Buy\"]))\r\n                    loss_percents.append(abs(d) / buy_price[j[:3]])\r\n                    valume[j[:3]] -= (valume[j[:3]] / len(action[\"SellNotAll\"] + action[\"Buy\"])) * len(action[\"Buy\"])\r\n                    balance[\"Current\"] -= loss[-1]\r\n                    # Max_DD_arr.append((max(balance[\"Current\"]) - min(balance[\"Current\"])) / max(balance[\"Current\"]))\r\n                    isProfitOrLoss.append(0)\r\n\r\n            for j in action[\"Buy\"]:\r\n                buy_count += 1\r\n                if valume[self.currency[0]] > 0 and len(j) > 0:\r\n                    d = self.strategy[self.currency_pair[0]].close_data[i] - buy_price[self.currency[0]]\r\n                    balance[\"Available\"] = valume[self.currency[0]] * \\\r\n                                           self.strategy[self.currency_pair[0]].close_data[i]\r\n                    if d > 0:\r\n                        profit.append(d * valume[self.currency[0]])\r\n                        profit_percents.append(d / buy_price[self.currency[0]])\r\n                        valume[self.currency[0]] = 0\r\n                        balance[\"Current\"] += profit[-1]\r\n                        # Max_DD_arr.append((max(balance[\"Current\"]) - min(balance[\"Current\"])) / max(balance[\"Current\"]))\r\n                        isProfitOrLoss.append(1)\r\n                    else:\r\n                        loss.append(abs(d) * valume[self.currency[0]])\r\n                        loss_percents.append(abs(d) / buy_price[self.currency[0]])\r\n                        valume[self.currency[0]] = 0\r\n                        balance[\"Current\"] -= loss[-1]\r\n                        # Max_DD_arr.append((max(balance[\"Current\"]) - min(balance[\"Current\"])) / max(balance[\"Current\"]))\r\n                        isProfitOrLoss.append(0)\r\n\r\n                if self.currency[-1] in j:\r\n                    buy_price[j[:3]] = ((buy_price[j[:3]] * valume[j[:3]]) + self.strategy[j].close_data[i] *\r\n                                        ((balance[\"Available\"] / len(action[\"Buy\"])) /\r\n                                         self.strategy[j].close_data[i]))\\\r\n                                       / (((balance[\"Available\"] / len(action[\"Buy\"])) /\r\n                                          self.strategy[j].close_data[i]) + valume[j[:3]])\r\n                    valume[j[:3]] += ((balance[\"Available\"] / len(action[\"Buy\"])) / self.strategy[j].close_data[i])\r\n                else:\r\n                    buy_price[j[:3]] = ((buy_price[j[:3]] * valume[j[:3]]) +\r\n                                        self.strategy[j[:3] + self.currency[-1]].close_data[i] *\r\n                                        ((balance[\"Available\"] / len(action[\"Buy\"])) /\r\n                                         self.strategy[j[:3] + self.currency[-1]].close_data[i]))\\\r\n                                       / (((balance[\"Available\"] / len(action[\"Buy\"])) /\r\n                                           (self.strategy[j[:3] + self.currency[-1]].close_data[i])) + valume[j[:3]])\r\n                    valume[j[:3]] += ((balance[\"Available\"] / len(action[\"Buy\"])) / self.strategy[j[:3] + self.currency[-1]].close_data[i])\r\n            if len(action[\"Buy\"]) > 0:\r\n                balance[\"Available\"] = 0\r\n\r\n            # print(action)\r\n        if len(loss) == 0:\r\n            profit_factor = sum(profit)\r\n        else:\r\n            profit_factor = sum(profit) / sum(loss)\r\n\r\n        p = 0\r\n        l = 0\r\n        profit_count = []\r\n        loss_count = []\r\n        for i in isProfitOrLoss:\r\n            if i == 1:\r\n                p += 1\r\n                if l != 0:\r\n                    loss_count.append(l)\r\n                    l = 0\r\n            if i == 0:\r\n                l += 1\r\n                if p != 0:\r\n                    profit_count.append(p)\r\n                    p = 0\r\n        try:\r\n            # row = [self.param[self.currency_pair[0]][\"Win1\"], self.param[self.currency_pair[0]][\"Win2\"],\r\n            #        self.param[self.currency_pair[0]][\"Win3\"], self.param[self.currency_pair[0]][\"t\"],\r\n            #        self.param[self.currency_pair[0]][\"a\"], self.param[self.currency_pair[0]][\"b\"]]\\\r\n            #       + [k for k in balance[\"All\"]]\r\n\r\n            row = [\"Algorithm_4\", self.param[self.currency_pair[0]][\"Win1\"],\r\n                   self.param[self.currency_pair[0]][\"Win2\"],\r\n                   self.param[self.currency_pair[0]][\"Win3\"], self.param[self.currency_pair[0]][\"t\"],\r\n                   self.param[self.currency_pair[0]][\"a\"],\r\n                   balance[\"Current\"] - 1000, sum(profit), max(profit_percents), sum(loss), max(loss_percents),\r\n                   profit_factor, len(profit) / len(profit+loss), len(loss) / len(profit+loss), len(profit+loss),\r\n                   (balance[\"Current\"] - 1000) / len(profit+loss), max(profit_count), sum(profit_count) / len(profit_count),\r\n                   max(loss_count), sum(loss_count) / len(loss_count), 0, 0]\r\n        except ZeroDivisionError:\r\n            row = [\"Algorithm_2\", self.param[self.currency_pair[0]][\"Win1\"],\r\n                   self.param[self.currency_pair[0]][\"Win2\"],\r\n                   self.param[self.currency_pair[0]][\"Win3\"], self.param[self.currency_pair[0]][\"t\"],\r\n                   self.param[self.currency_pair[0]][\"a\"], self.param[self.currency_pair[0]][\"b\"],\r\n                   balance[\"Current\"] - 1000, sum(profit), max(profit_percents), sum(loss),\r\n                          max(loss_percents), profit_factor, 0, 0, sell_count, 0, 0, 0,\r\n                          max(loss_count), 0, 0, 0]\r\n\r\n        self.result_row.append(row)\r\n        # print(row)\r\n\r\nclass Algorithm_5(Algorithm_4):\r\n    strategy = {}\r\n    def __init__(self, candle, currency, start, stop):\r\n\r\n        start_time = start\r\n        end_time = stop\r\n\r\n        self.currency = currency\r\n        self.currency_pair = []\r\n        for i in self.currency[:-1]:\r\n            self.currency_pair.append(i+self.currency[-1])\r\n        self.currency_pair_secondery = []\r\n        for i in self.currency[1:-1]:\r\n            self.currency_pair_secondery.append(i+self.currency[0])\r\n\r\n        self.correspond_currency = {}\r\n        for i, item in enumerate(self.currency_pair_secondery):\r\n            self.correspond_currency[self.currency[i+1]] = self.currency_pair[i+1]\r\n            self.correspond_currency[self.currency_pair[i+1]] = item\r\n\r\n        use_offline_data = False\r\n        for i in self.currency_pair + self.currency_pair_secondery:\r\n            if use_offline_data:\r\n                self.klines[i] = (FileWorking.ReadKlines(\"Data\\\\\" + i + \"_1HOUR_\" + start_time.isoformat() + \"_\" +\r\n                                                         end_time.isoformat() + \".txt\"))\r\n            else:\r\n                self.klines[i] = (candle.getKlines(i, Client.KLINE_INTERVAL_1HOUR, start_time.strftime(\"%d %b, %Y\"),\r\n                                                   end_time.strftime(\"%d %b, %Y\")))\r\n                FileWorking.WriteKlines(self.klines[i], \"Data\\\\\" + i + \"_1HOUR_\" + start_time.isoformat() + \"_\" +\r\n                                        end_time.isoformat() + \".txt\")\r\n            candle.unpackCandle(self.klines[i])\r\n            high = pd.Series(candle.high)\r\n            low = pd.Series(candle.low)\r\n\r\n            self.close_data = candle.close\r\n\r\n            # self.strategy[i] = (ICHIMOKU_2_Strategy(high, low, self.close_data))\r\n            # self.strategy[i] = (ICHIMOKU_STOCASTIC_Strategy(high, low, self.close_data))\r\n            # self.strategy[i] = (ICHIMOKU_Strategy_Test(high, low, self.close_data))\r\n            # self.strategy[i] = (ICHIMOKU_Strategy_HMA(high, low, self.close_data))\r\n            self.strategy[i] = (ICHIMOKU_Strategy_HMA_Keltner(high, low, self.close_data, i))\r\n        self.file = CSVFiles(\"Result/Algorithm_6-\" + start_time.strftime(\"%Y-%m-%d_\") + end_time.strftime(\"%Y-%m-%d_\") +\r\n                             self.currency_pair_secondery[0] + \".csv\")\r\n        self.result_row = []\r\n        self.Buy_Signal = {}\r\n        self.param = {}\r\n        self.BS = {}\r\n\r\n    def SetAlgorithmParam(self, currency_pair, p):\r\n        self.param[currency_pair] = p\r\n\r\n    def BuySignalThread(self, param, currency):\r\n        self.BS[currency] = [False] * len(self.klines[currency])\r\n        update_strategy = True\r\n        isNotPos = True\r\n        j = 1\r\n        while j < len(self.klines[currency]) - 1:\r\n            if update_strategy:\r\n                self.strategy[currency].ComputeIchimoku_A(param[currency][\"Win1\"], param[currency][\"Win2\"])\r\n                self.strategy[currency].ComputeIchimoku_B(param[currency][\"Win2\"], param[currency][\"Win3\"])\r\n                self.strategy[currency].ComputeIchimoku_Base_Line(param[currency][\"Win1\"], param[currency][\"Win2\"])\r\n                self.strategy[currency].ComputeIchimoku_Conversion_Line(param[currency][\"Win1\"], param[currency][\"Win2\"])\r\n                # self.strategy[currency].ComputeWilliamsR(param[currency][\"R_Period\"])\r\n                # self.strategy[currency].ComputeSTOCASTIC(param[currency][\"FastK\"], param[currency][\"SlowK\"],\r\n                #                                          param[currency][\"SlowD\"])\r\n                # self.strategy[currency].ComputeMACD(param[currency][\"Fast\"], param[currency][\"Slow\"],\r\n                #                                          param[currency][\"Signal\"])\r\n                # self.strategy[currency].ComputeEMA(param[currency][\"EMA_Period\"])\r\n                # self.strategy[currency].ComputeHMA(param[currency][\"HMA_Period\"])\r\n                # self.strategy[currency].ComputeTEMA(param[currency][\"TEMA_Period\"])\r\n                self.strategy[currency].ComputeKeltnerChannel(param[currency][\"keltner_Window\"], 12, param[currency][\"Multi_ATR\"])\r\n                self.strategy[currency].ComputeMcGinleyDynamic(param[currency][\"McGinley_Period\"])\r\n            buy_event = self.strategy[currency].BuyStrategy(j, param[currency][\"t\"], param[currency][\"a\"])\r\n            sell_event = self.strategy[currency].SellStrategy(j, param[currency][\"t\"])\r\n            if buy_event and isNotPos:\r\n                self.BS[currency][j] = True\r\n                isNotPos = False\r\n            elif not isNotPos:\r\n                if j - param[currency][\"t\"] - 1 > 0:\r\n                    if sell_event:\r\n                        self.BS[currency][j] = False\r\n                        isNotPos = True\r\n                    else:\r\n                        self.BS[currency][j] = True\r\n            update_strategy = False\r\n            j += 1\r\n\r\n    def LogResult(self):\r\n        fieldnames = ['Strategy', 'Win1', 'Win2', 'Win3', 't', 'a', 'McGinley_Period', \"keltner_Window\", 'Multi_ATR',\r\n                      'Total Net Profit',\r\n                      'Gross Profit', 'Max Profit', 'Avg Profit', 'Gross Loss', 'Max Loss', 'Avg Loss', 'Profit Factor',\r\n                      'Profit Trade (%)', 'Loss Trade (%)', 'Total Trade', 'Expected Payoff', 'Max Consecutive Wins',\r\n                      'Avg Consecutive Wins', 'Max Consecutive Loss', 'Avg Consecutive Loss',\r\n                      'Max Draw Down (%)', 'Max Draw Down (Time)']\r\n\r\n        # fieldnames = [\"Win1\", \"Win2\", \"Win3\", \"t\", \"a\"]\r\n        # fieldnames = fieldnames + [\"Order\" + str(k + 1) for k in range(0, 200)]\r\n        self.WriteResult(fieldnames, self.result_row)\r\n\r\n    def RunAlgorithm(self):\r\n        balance = {\"Current\": 1000, \"Max\": 1000, \"Min\": 1000, \"Available\": 1000, \"All\": []}\r\n        self.isPos = {}\r\n        valume = {}\r\n        buy_price = {}\r\n        for i in self.currency:\r\n            self.isPos[i] = False\r\n            valume[i] = 0\r\n            buy_price[i] = 0\r\n        profit = []\r\n        loss = []\r\n        isProfitOrLoss = []\r\n        profit_percents = []\r\n        loss_percents = []\r\n        buy_count = 0\r\n        sell_count = 0\r\n        Max_DD_arr = []\r\n        for i in range(1, len(self.klines[self.currency_pair[0]]) - 1):\r\n            action = self.CheckAction(i)\r\n            for j in action[\"Sell\"]:\r\n                sell_count += 1\r\n                if self.currency[-1] in j:\r\n                    jj = j.replace(self.currency[-1], '')\r\n                    d = self.strategy[j].close_data[i] - buy_price[jj]\r\n                    balance[\"Available\"] += valume[jj] * self.strategy[j].close_data[i]\r\n                else:\r\n                    jj = j.replace(self.currency[0], '')\r\n                    d = self.strategy[jj + self.currency[-1]].close_data[i] - buy_price[jj]\r\n                    balance[\"Available\"] += valume[jj] * self.strategy[jj + self.currency[-1]].close_data[i]\r\n\r\n                if d > 0:\r\n                    profit.append(d * valume[jj])\r\n                    profit_percents.append(profit[-1] / balance[\"Current\"])\r\n                    balance[\"Current\"] += profit[-1]\r\n                    balance[\"All\"].append(balance[\"Current\"])\r\n                    # Max_DD_arr.append((max(balance[\"Current\"]) - min(balance[\"Current\"])) / max(balance[\"Current\"]))\r\n                    valume[jj] = 0\r\n                    isProfitOrLoss.append(1)\r\n                else:\r\n                    loss.append(abs(d) * valume[jj])\r\n                    loss_percents.append(loss[-1] / balance[\"Current\"])\r\n                    valume[jj] = 0\r\n                    balance[\"Current\"] -= loss[-1]\r\n                    balance[\"All\"].append(balance[\"Current\"])\r\n                    # Max_DD_arr.append((max(balance[\"Current\"]) - min(balance[\"Current\"])) / max(balance[\"Current\"]))\r\n                    isProfitOrLoss.append(0)\r\n\r\n                if valume[self.currency[0]] == 0 and len(action[\"Buy\"]) == 0:\r\n                    if j[3:] == self.currency[0]:\r\n                        buy_price[self.currency[0]] = self.strategy[self.currency_pair[0]].close_data[i]\r\n                        valume[self.currency[0]] = balance[\"Available\"] / buy_price[self.currency[0]]\r\n                        balance[\"Available\"] = 0\r\n\r\n            for j in action[\"SellNotAll\"]:\r\n                sell_count +=1\r\n                if self.currency[-1] in j:\r\n                    jj = j.replace(self.currency[-1], '')\r\n                    d = self.strategy[j].close_data[i] - buy_price[jj]\r\n                    balance[\"Available\"] += (valume[jj] / len(action[\"SellNotAll\"] + action[\"Buy\"])) *\\\r\n                                            len(action[\"Buy\"]) * self.strategy[j].close_data[i]\r\n                else:\r\n                    jj = j.replace(self.currency[0], '')\r\n                    d = self.strategy[jj + self.currency[-1]].close_data[i] - buy_price[jj]\r\n                    balance[\"Available\"] += (valume[jj] / len(action[\"SellNotAll\"] + action[\"Buy\"])) *\\\r\n                                            len(action[\"Buy\"]) * self.strategy[jj + self.currency[-1]].close_data[i]\r\n                if d > 0:\r\n                    profit.append(d * (valume[jj] / len(action[\"SellNotAll\"] + action[\"Buy\"])) * len(action[\"Buy\"]))\r\n                    profit_percents.append(profit[-1] / balance[\"Current\"])\r\n                    valume[jj] -= (valume[jj] / len(action[\"SellNotAll\"] + action[\"Buy\"])) * len(action[\"Buy\"])\r\n                    balance[\"Current\"] += profit[-1]\r\n                    # Max_DD_arr.append((max(balance[\"Current\"]) - min(balance[\"Current\"])) / max(balance[\"Current\"]))\r\n                    isProfitOrLoss.append(1)\r\n                else:\r\n                    loss.append(abs(d) * (valume[jj] / len(action[\"SellNotAll\"] + action[\"Buy\"])) * len(action[\"Buy\"]))\r\n                    loss_percents.append(loss[-1] / balance[\"Current\"])\r\n                    valume[jj] -= (valume[jj] / len(action[\"SellNotAll\"] + action[\"Buy\"])) * len(action[\"Buy\"])\r\n                    balance[\"Current\"] -= loss[-1]\r\n                    # Max_DD_arr.append((max(balance[\"Current\"]) - min(balance[\"Current\"])) / max(balance[\"Current\"]))\r\n                    isProfitOrLoss.append(0)\r\n\r\n            for j in action[\"Buy\"]:\r\n                buy_count += 1\r\n                if valume[self.currency[0]] > 0 and len(j) > 0:\r\n                    d = self.strategy[self.currency_pair[0]].close_data[i] - buy_price[self.currency[0]]\r\n                    balance[\"Available\"] = valume[self.currency[0]] * \\\r\n                                           self.strategy[self.currency_pair[0]].close_data[i]\r\n                    if d > 0:\r\n                        profit.append(d * valume[self.currency[0]])\r\n                        profit_percents.append(profit[-1] / balance[\"Current\"])\r\n                        valume[self.currency[0]] = 0\r\n                        balance[\"Current\"] += profit[-1]\r\n                        # Max_DD_arr.append((max(balance[\"Current\"]) - min(balance[\"Current\"])) / max(balance[\"Current\"]))\r\n                        isProfitOrLoss.append(1)\r\n                    else:\r\n                        loss.append(abs(d) * valume[self.currency[0]])\r\n                        loss_percents.append(loss[-1] / balance[\"Current\"])\r\n                        valume[self.currency[0]] = 0\r\n                        balance[\"Current\"] -= loss[-1]\r\n                        # Max_DD_arr.append((max(balance[\"Current\"]) - min(balance[\"Current\"])) / max(balance[\"Current\"]))\r\n                        isProfitOrLoss.append(0)\r\n\r\n                if self.currency[-1] in j:\r\n                    jj = j.replace(self.currency[-1], '')\r\n                    buy_price[jj] = ((buy_price[jj] * valume[jj]) + self.strategy[j].close_data[i] *\r\n                                        ((balance[\"Available\"] / len(action[\"Buy\"])) /\r\n                                         self.strategy[j].close_data[i]))\\\r\n                                       / (((balance[\"Available\"] / len(action[\"Buy\"])) /\r\n                                          self.strategy[j].close_data[i]) + valume[jj])\r\n                    valume[jj] += ((balance[\"Available\"] / len(action[\"Buy\"])) / self.strategy[j].close_data[i])\r\n                else:\r\n                    jj = j.replace(self.currency[0], '')\r\n                    buy_price[jj] = ((buy_price[jj] * valume[jj]) +\r\n                                        self.strategy[jj + self.currency[-1]].close_data[i] *\r\n                                        ((balance[\"Available\"] / len(action[\"Buy\"])) /\r\n                                         self.strategy[jj + self.currency[-1]].close_data[i]))\\\r\n                                       / (((balance[\"Available\"] / len(action[\"Buy\"])) /\r\n                                           (self.strategy[jj + self.currency[-1]].close_data[i])) + valume[jj])\r\n                    valume[jj] += ((balance[\"Available\"] / len(action[\"Buy\"])) / self.strategy[jj + self.currency[-1]].close_data[i])\r\n            if len(action[\"Buy\"]) > 0:\r\n                balance[\"Available\"] = 0\r\n\r\n            # print(action)\r\n        if len(loss) == 0:\r\n            profit_factor = sum(profit)\r\n        else:\r\n            profit_factor = sum(profit) / sum(loss)\r\n\r\n        p = 0\r\n        l = 0\r\n        profit_count = []\r\n        loss_count = []\r\n        for i in isProfitOrLoss:\r\n            if i == 1:\r\n                p += 1\r\n                if l != 0:\r\n                    loss_count.append(l)\r\n                    l = 0\r\n            if i == 0:\r\n                l += 1\r\n                if p != 0:\r\n                    profit_count.append(p)\r\n                    p = 0\r\n        try:\r\n            # row = [self.param[self.currency_pair[0]][\"Win1\"], self.param[self.currency_pair[0]][\"Win2\"],\r\n            #        self.param[self.currency_pair[0]][\"Win3\"], self.param[self.currency_pair[0]][\"t\"],\r\n            #        self.param[self.currency_pair[0]][\"a\"], self.param[self.currency_pair[0]][\"b\"]]\\\r\n            #       + [k for k in balance[\"All\"]]\r\n\r\n            row = [\"Algorithm_5\", self.param[self.currency_pair_secondery[0]][\"Win1\"],\r\n                   self.param[self.currency_pair_secondery[0]][\"Win2\"],\r\n                   self.param[self.currency_pair_secondery[0]][\"Win3\"], self.param[self.currency_pair_secondery[0]][\"t\"],\r\n                   self.param[self.currency_pair_secondery[0]][\"a\"],\r\n                   self.param[self.currency_pair_secondery[0]][\"McGinley_Period\"],\r\n                   self.param[self.currency_pair_secondery[0]][\"keltner_Window\"],\r\n                   self.param[self.currency_pair_secondery[0]][\"Multi_ATR\"],\r\n                   balance[\"Current\"] - 1000, sum(profit), max(profit_percents),\r\n                   sum(profit_percents) / len(profit_percents), sum(loss), max(loss_percents),\r\n                   sum(loss_percents) / len(loss_percents), profit_factor, len(profit) / len(profit+loss),\r\n                   len(loss) / len(profit+loss), len(profit+loss), (balance[\"Current\"] - 1000) / len(profit+loss),\r\n                   max(profit_count), sum(profit_count) / len(profit_count), max(loss_count),\r\n                   sum(loss_count) / len(loss_count), 0, 0]\r\n        except ZeroDivisionError:\r\n            row = [\"Algorithm_5\", self.param[self.currency_pair_secondery[0]][\"Win1\"],\r\n                   self.param[self.currency_pair_secondery[0]][\"Win2\"],\r\n                   self.param[self.currency_pair_secondery[0]][\"Win3\"], self.param[self.currency_pair_secondery[0]][\"t\"],\r\n                   self.param[self.currency_pair_secondery[0]][\"a\"],\r\n                   self.param[self.currency_pair_secondery[0]][\"McGinley_Period\"],\r\n                   self.param[self.currency_pair_secondery[0]][\"keltner_Window\"],\r\n                   self.param[self.currency_pair_secondery[0]][\"Multi_ATR\"],\r\n                   balance[\"Current\"] - 1000, sum(profit), max(profit_percents), 0, sum(loss),\r\n                          max(loss_percents), 0, profit_factor, 0, 0, sell_count, 0, 0, 0,\r\n                          max(loss_count), 0, 0, 0]\r\n\r\n        self.result_row.append(row)\r\n        # print(row)\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/BackTest.py b/BackTest.py
--- a/BackTest.py	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
+++ b/BackTest.py	(date 1632847356450)
@@ -1268,7 +1268,7 @@
             self.correspond_currency[self.currency[i+1]] = self.currency_pair[i+1]
             self.correspond_currency[self.currency_pair[i+1]] = item
 
-        use_offline_data = False
+        use_offline_data = True
         for i in self.currency_pair + self.currency_pair_secondery:
             if use_offline_data:
                 self.klines[i] = (FileWorking.ReadKlines("Data\\" + i + "_1HOUR_" + start_time.isoformat() + "_" +
Index: venv/Lib/tcl8.6/init.tcl
===================================================================
diff --git a/venv/Lib/tcl8.6/init.tcl b/venv/Lib/tcl8.6/init.tcl
deleted file mode 100644
--- a/venv/Lib/tcl8.6/init.tcl	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
+++ /dev/null	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
@@ -1,818 +0,0 @@
-# init.tcl --
-#
-# Default system startup file for Tcl-based applications.  Defines
-# "unknown" procedure and auto-load facilities.
-#
-# Copyright (c) 1991-1993 The Regents of the University of California.
-# Copyright (c) 1994-1996 Sun Microsystems, Inc.
-# Copyright (c) 1998-1999 Scriptics Corporation.
-# Copyright (c) 2004 by Kevin B. Kenny.  All rights reserved.
-#
-# See the file "license.terms" for information on usage and redistribution
-# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
-#
-
-# This test intentionally written in pre-7.5 Tcl
-if {[info commands package] == ""} {
-    error "version mismatch: library\nscripts expect Tcl version 7.5b1 or later but the loaded version is\nonly [info patchlevel]"
-}
-package require -exact Tcl 8.6.6
-
-# Compute the auto path to use in this interpreter.
-# The values on the path come from several locations:
-#
-# The environment variable TCLLIBPATH
-#
-# tcl_library, which is the directory containing this init.tcl script.
-# [tclInit] (Tcl_Init()) searches around for the directory containing this
-# init.tcl and defines tcl_library to that location before sourcing it.
-#
-# The parent directory of tcl_library. Adding the parent
-# means that packages in peer directories will be found automatically.
-#
-# Also add the directory ../lib relative to the directory where the
-# executable is located.  This is meant to find binary packages for the
-# same architecture as the current executable.
-#
-# tcl_pkgPath, which is set by the platform-specific initialization routines
-#	On UNIX it is compiled in
-#       On Windows, it is not used
-
-if {![info exists auto_path]} {
-    if {[info exists env(TCLLIBPATH)]} {
-	set auto_path $env(TCLLIBPATH)
-    } else {
-	set auto_path ""
-    }
-}
-namespace eval tcl {
-    variable Dir
-    foreach Dir [list $::tcl_library [file dirname $::tcl_library]] {
-	if {$Dir ni $::auto_path} {
-	    lappend ::auto_path $Dir
-	}
-    }
-    set Dir [file join [file dirname [file dirname \
-	    [info nameofexecutable]]] lib]
-    if {$Dir ni $::auto_path} {
-	lappend ::auto_path $Dir
-    }
-    catch {
-	foreach Dir $::tcl_pkgPath {
-	    if {$Dir ni $::auto_path} {
-		lappend ::auto_path $Dir
-	    }
-	}
-    }
-
-    if {![interp issafe]} {
-        variable Path [encoding dirs]
-        set Dir [file join $::tcl_library encoding]
-        if {$Dir ni $Path} {
-	    lappend Path $Dir
-	    encoding dirs $Path
-        }
-    }
-
-    # TIP #255 min and max functions
-    namespace eval mathfunc {
-	proc min {args} {
-	    if {![llength $args]} {
-		return -code error \
-		    "too few arguments to math function \"min\""
-	    }
-	    set val Inf
-	    foreach arg $args {
-		# This will handle forcing the numeric value without
-		# ruining the internal type of a numeric object
-		if {[catch {expr {double($arg)}} err]} {
-		    return -code error $err
-		}
-		if {$arg < $val} {set val $arg}
-	    }
-	    return $val
-	}
-	proc max {args} {
-	    if {![llength $args]} {
-		return -code error \
-		    "too few arguments to math function \"max\""
-	    }
-	    set val -Inf
-	    foreach arg $args {
-		# This will handle forcing the numeric value without
-		# ruining the internal type of a numeric object
-		if {[catch {expr {double($arg)}} err]} {
-		    return -code error $err
-		}
-		if {$arg > $val} {set val $arg}
-	    }
-	    return $val
-	}
-	namespace export min max
-    }
-}
-
-# Windows specific end of initialization
-
-if {(![interp issafe]) && ($tcl_platform(platform) eq "windows")} {
-    namespace eval tcl {
-	proc EnvTraceProc {lo n1 n2 op} {
-	    global env
-	    set x $env($n2)
-	    set env($lo) $x
-	    set env([string toupper $lo]) $x
-	}
-	proc InitWinEnv {} {
-	    global env tcl_platform
-	    foreach p [array names env] {
-		set u [string toupper $p]
-		if {$u ne $p} {
-		    switch -- $u {
-			COMSPEC -
-			PATH {
-			    set temp $env($p)
-			    unset env($p)
-			    set env($u) $temp
-			    trace add variable env($p) write \
-				    [namespace code [list EnvTraceProc $p]]
-			    trace add variable env($u) write \
-				    [namespace code [list EnvTraceProc $p]]
-			}
-		    }
-		}
-	    }
-	    if {![info exists env(COMSPEC)]} {
-		set env(COMSPEC) cmd.exe
-	    }
-	}
-	InitWinEnv
-    }
-}
-
-# Setup the unknown package handler
-
-
-if {[interp issafe]} {
-    package unknown {::tcl::tm::UnknownHandler ::tclPkgUnknown}
-} else {
-    # Set up search for Tcl Modules (TIP #189).
-    # and setup platform specific unknown package handlers
-    if {$tcl_platform(os) eq "Darwin"
-	    && $tcl_platform(platform) eq "unix"} {
-	package unknown {::tcl::tm::UnknownHandler \
-		{::tcl::MacOSXPkgUnknown ::tclPkgUnknown}}
-    } else {
-	package unknown {::tcl::tm::UnknownHandler ::tclPkgUnknown}
-    }
-
-    # Set up the 'clock' ensemble
-
-    namespace eval ::tcl::clock [list variable TclLibDir $::tcl_library]
-
-    proc clock args {
-	namespace eval ::tcl::clock [list namespace ensemble create -command \
-		[uplevel 1 [list namespace origin [lindex [info level 0] 0]]] \
-		-subcommands {
-		    add clicks format microseconds milliseconds scan seconds
-		}]
-
-	# Auto-loading stubs for 'clock.tcl'
-
-	foreach cmd {add format scan} {
-	    proc ::tcl::clock::$cmd args {
-		variable TclLibDir
-		source -encoding utf-8 [file join $TclLibDir clock.tcl]
-		return [uplevel 1 [info level 0]]
-	    }
-	}
-
-	return [uplevel 1 [info level 0]]
-    }
-}
-
-# Conditionalize for presence of exec.
-
-if {[namespace which -command exec] eq ""} {
-
-    # Some machines do not have exec. Also, on all
-    # platforms, safe interpreters do not have exec.
-
-    set auto_noexec 1
-}
-
-# Define a log command (which can be overwitten to log errors
-# differently, specially when stderr is not available)
-
-if {[namespace which -command tclLog] eq ""} {
-    proc tclLog {string} {
-	catch {puts stderr $string}
-    }
-}
-
-# unknown --
-# This procedure is called when a Tcl command is invoked that doesn't
-# exist in the interpreter.  It takes the following steps to make the
-# command available:
-#
-#	1. See if the autoload facility can locate the command in a
-#	   Tcl script file.  If so, load it and execute it.
-#	2. If the command was invoked interactively at top-level:
-#	    (a) see if the command exists as an executable UNIX program.
-#		If so, "exec" the command.
-#	    (b) see if the command requests csh-like history substitution
-#		in one of the common forms !!, !<number>, or ^old^new.  If
-#		so, emulate csh's history substitution.
-#	    (c) see if the command is a unique abbreviation for another
-#		command.  If so, invoke the command.
-#
-# Arguments:
-# args -	A list whose elements are the words of the original
-#		command, including the command name.
-
-proc unknown args {
-    variable ::tcl::UnknownPending
-    global auto_noexec auto_noload env tcl_interactive errorInfo errorCode
-
-    if {[info exists errorInfo]} {
-	set savedErrorInfo $errorInfo
-    }
-    if {[info exists errorCode]} {
-	set savedErrorCode $errorCode
-    }
-
-    set name [lindex $args 0]
-    if {![info exists auto_noload]} {
-	#
-	# Make sure we're not trying to load the same proc twice.
-	#
-	if {[info exists UnknownPending($name)]} {
-	    return -code error "self-referential recursion\
-		    in \"unknown\" for command \"$name\""
-	}
-	set UnknownPending($name) pending
-	set ret [catch {
-		auto_load $name [uplevel 1 {::namespace current}]
-	} msg opts]
-	unset UnknownPending($name)
-	if {$ret != 0} {
-	    dict append opts -errorinfo "\n    (autoloading \"$name\")"
-	    return -options $opts $msg
-	}
-	if {![array size UnknownPending]} {
-	    unset UnknownPending
-	}
-	if {$msg} {
-	    if {[info exists savedErrorCode]} {
-		set ::errorCode $savedErrorCode
-	    } else {
-		unset -nocomplain ::errorCode
-	    }
-	    if {[info exists savedErrorInfo]} {
-		set errorInfo $savedErrorInfo
-	    } else {
-		unset -nocomplain errorInfo
-	    }
-	    set code [catch {uplevel 1 $args} msg opts]
-	    if {$code ==  1} {
-		#
-		# Compute stack trace contribution from the [uplevel].
-		# Note the dependence on how Tcl_AddErrorInfo, etc.
-		# construct the stack trace.
-		#
-		set errInfo [dict get $opts -errorinfo]
-		set errCode [dict get $opts -errorcode]
-		set cinfo $args
-		if {[string bytelength $cinfo] > 150} {
-		    set cinfo [string range $cinfo 0 150]
-		    while {[string bytelength $cinfo] > 150} {
-			set cinfo [string range $cinfo 0 end-1]
-		    }
-		    append cinfo ...
-		}
-		append cinfo "\"\n    (\"uplevel\" body line 1)"
-		append cinfo "\n    invoked from within"
-		append cinfo "\n\"uplevel 1 \$args\""
-		#
-		# Try each possible form of the stack trace
-		# and trim the extra contribution from the matching case
-		#
-		set expect "$msg\n    while executing\n\"$cinfo"
-		if {$errInfo eq $expect} {
-		    #
-		    # The stack has only the eval from the expanded command
-		    # Do not generate any stack trace here.
-		    #
-		    dict unset opts -errorinfo
-		    dict incr opts -level
-		    return -options $opts $msg
-		}
-		#
-		# Stack trace is nested, trim off just the contribution
-		# from the extra "eval" of $args due to the "catch" above.
-		#
-		set expect "\n    invoked from within\n\"$cinfo"
-		set exlen [string length $expect]
-		set eilen [string length $errInfo]
-		set i [expr {$eilen - $exlen - 1}]
-		set einfo [string range $errInfo 0 $i]
-		#
-		# For now verify that $errInfo consists of what we are about
-		# to return plus what we expected to trim off.
-		#
-		if {$errInfo ne "$einfo$expect"} {
-		    error "Tcl bug: unexpected stack trace in \"unknown\"" {} \
-			[list CORE UNKNOWN BADTRACE $einfo $expect $errInfo]
-		}
-		return -code error -errorcode $errCode \
-			-errorinfo $einfo $msg
-	    } else {
-		dict incr opts -level
-		return -options $opts $msg
-	    }
-	}
-    }
-
-    if {([info level] == 1) && ([info script] eq "")
-	    && [info exists tcl_interactive] && $tcl_interactive} {
-	if {![info exists auto_noexec]} {
-	    set new [auto_execok $name]
-	    if {$new ne ""} {
-		set redir ""
-		if {[namespace which -command console] eq ""} {
-		    set redir ">&@stdout <@stdin"
-		}
-		uplevel 1 [list ::catch \
-			[concat exec $redir $new [lrange $args 1 end]] \
-			::tcl::UnknownResult ::tcl::UnknownOptions]
-		dict incr ::tcl::UnknownOptions -level
-		return -options $::tcl::UnknownOptions $::tcl::UnknownResult
-	    }
-	}
-	if {$name eq "!!"} {
-	    set newcmd [history event]
-	} elseif {[regexp {^!(.+)$} $name -> event]} {
-	    set newcmd [history event $event]
-	} elseif {[regexp {^\^([^^]*)\^([^^]*)\^?$} $name -> old new]} {
-	    set newcmd [history event -1]
-	    catch {regsub -all -- $old $newcmd $new newcmd}
-	}
-	if {[info exists newcmd]} {
-	    tclLog $newcmd
-	    history change $newcmd 0
-	    uplevel 1 [list ::catch $newcmd \
-		    ::tcl::UnknownResult ::tcl::UnknownOptions]
-	    dict incr ::tcl::UnknownOptions -level
-	    return -options $::tcl::UnknownOptions $::tcl::UnknownResult
-	}
-
-	set ret [catch {set candidates [info commands $name*]} msg]
-	if {$name eq "::"} {
-	    set name ""
-	}
-	if {$ret != 0} {
-	    dict append opts -errorinfo \
-		    "\n    (expanding command prefix \"$name\" in unknown)"
-	    return -options $opts $msg
-	}
-	# Filter out bogus matches when $name contained
-	# a glob-special char [Bug 946952]
-	if {$name eq ""} {
-	    # Handle empty $name separately due to strangeness
-	    # in [string first] (See RFE 1243354)
-	    set cmds $candidates
-	} else {
-	    set cmds [list]
-	    foreach x $candidates {
-		if {[string first $name $x] == 0} {
-		    lappend cmds $x
-		}
-	    }
-	}
-	if {[llength $cmds] == 1} {
-	    uplevel 1 [list ::catch [lreplace $args 0 0 [lindex $cmds 0]] \
-		    ::tcl::UnknownResult ::tcl::UnknownOptions]
-	    dict incr ::tcl::UnknownOptions -level
-	    return -options $::tcl::UnknownOptions $::tcl::UnknownResult
-	}
-	if {[llength $cmds]} {
-	    return -code error "ambiguous command name \"$name\": [lsort $cmds]"
-	}
-    }
-    return -code error -errorcode [list TCL LOOKUP COMMAND $name] \
-	"invalid command name \"$name\""
-}
-
-# auto_load --
-# Checks a collection of library directories to see if a procedure
-# is defined in one of them.  If so, it sources the appropriate
-# library file to create the procedure.  Returns 1 if it successfully
-# loaded the procedure, 0 otherwise.
-#
-# Arguments:
-# cmd -			Name of the command to find and load.
-# namespace (optional)  The namespace where the command is being used - must be
-#                       a canonical namespace as returned [namespace current]
-#                       for instance. If not given, namespace current is used.
-
-proc auto_load {cmd {namespace {}}} {
-    global auto_index auto_path
-
-    if {$namespace eq ""} {
-	set namespace [uplevel 1 [list ::namespace current]]
-    }
-    set nameList [auto_qualify $cmd $namespace]
-    # workaround non canonical auto_index entries that might be around
-    # from older auto_mkindex versions
-    lappend nameList $cmd
-    foreach name $nameList {
-	if {[info exists auto_index($name)]} {
-	    namespace eval :: $auto_index($name)
-	    # There's a couple of ways to look for a command of a given
-	    # name.  One is to use
-	    #    info commands $name
-	    # Unfortunately, if the name has glob-magic chars in it like *
-	    # or [], it may not match.  For our purposes here, a better
-	    # route is to use
-	    #    namespace which -command $name
-	    if {[namespace which -command $name] ne ""} {
-		return 1
-	    }
-	}
-    }
-    if {![info exists auto_path]} {
-	return 0
-    }
-
-    if {![auto_load_index]} {
-	return 0
-    }
-    foreach name $nameList {
-	if {[info exists auto_index($name)]} {
-	    namespace eval :: $auto_index($name)
-	    if {[namespace which -command $name] ne ""} {
-		return 1
-	    }
-	}
-    }
-    return 0
-}
-
-# auto_load_index --
-# Loads the contents of tclIndex files on the auto_path directory
-# list.  This is usually invoked within auto_load to load the index
-# of available commands.  Returns 1 if the index is loaded, and 0 if
-# the index is already loaded and up to date.
-#
-# Arguments:
-# None.
-
-proc auto_load_index {} {
-    variable ::tcl::auto_oldpath
-    global auto_index auto_path
-
-    if {[info exists auto_oldpath] && ($auto_oldpath eq $auto_path)} {
-	return 0
-    }
-    set auto_oldpath $auto_path
-
-    # Check if we are a safe interpreter. In that case, we support only
-    # newer format tclIndex files.
-
-    set issafe [interp issafe]
-    for {set i [expr {[llength $auto_path] - 1}]} {$i >= 0} {incr i -1} {
-	set dir [lindex $auto_path $i]
-	set f ""
-	if {$issafe} {
-	    catch {source [file join $dir tclIndex]}
-	} elseif {[catch {set f [open [file join $dir tclIndex]]}]} {
-	    continue
-	} else {
-	    set error [catch {
-		set id [gets $f]
-		if {$id eq "# Tcl autoload index file, version 2.0"} {
-		    eval [read $f]
-		} elseif {$id eq "# Tcl autoload index file: each line identifies a Tcl"} {
-		    while {[gets $f line] >= 0} {
-			if {([string index $line 0] eq "#") \
-				|| ([llength $line] != 2)} {
-			    continue
-			}
-			set name [lindex $line 0]
-			set auto_index($name) \
-				"source [file join $dir [lindex $line 1]]"
-		    }
-		} else {
-		    error "[file join $dir tclIndex] isn't a proper Tcl index file"
-		}
-	    } msg opts]
-	    if {$f ne ""} {
-		close $f
-	    }
-	    if {$error} {
-		return -options $opts $msg
-	    }
-	}
-    }
-    return 1
-}
-
-# auto_qualify --
-#
-# Compute a fully qualified names list for use in the auto_index array.
-# For historical reasons, commands in the global namespace do not have leading
-# :: in the index key. The list has two elements when the command name is
-# relative (no leading ::) and the namespace is not the global one. Otherwise
-# only one name is returned (and searched in the auto_index).
-#
-# Arguments -
-# cmd		The command name. Can be any name accepted for command
-#               invocations (Like "foo::::bar").
-# namespace	The namespace where the command is being used - must be
-#               a canonical namespace as returned by [namespace current]
-#               for instance.
-
-proc auto_qualify {cmd namespace} {
-
-    # count separators and clean them up
-    # (making sure that foo:::::bar will be treated as foo::bar)
-    set n [regsub -all {::+} $cmd :: cmd]
-
-    # Ignore namespace if the name starts with ::
-    # Handle special case of only leading ::
-
-    # Before each return case we give an example of which category it is
-    # with the following form :
-    # (inputCmd, inputNameSpace) -> output
-
-    if {[string match ::* $cmd]} {
-	if {$n > 1} {
-	    # (::foo::bar , *) -> ::foo::bar
-	    return [list $cmd]
-	} else {
-	    # (::global , *) -> global
-	    return [list [string range $cmd 2 end]]
-	}
-    }
-
-    # Potentially returning 2 elements to try  :
-    # (if the current namespace is not the global one)
-
-    if {$n == 0} {
-	if {$namespace eq "::"} {
-	    # (nocolons , ::) -> nocolons
-	    return [list $cmd]
-	} else {
-	    # (nocolons , ::sub) -> ::sub::nocolons nocolons
-	    return [list ${namespace}::$cmd $cmd]
-	}
-    } elseif {$namespace eq "::"} {
-	#  (foo::bar , ::) -> ::foo::bar
-	return [list ::$cmd]
-    } else {
-	# (foo::bar , ::sub) -> ::sub::foo::bar ::foo::bar
-	return [list ${namespace}::$cmd ::$cmd]
-    }
-}
-
-# auto_import --
-#
-# Invoked during "namespace import" to make see if the imported commands
-# reside in an autoloaded library.  If so, the commands are loaded so
-# that they will be available for the import links.  If not, then this
-# procedure does nothing.
-#
-# Arguments -
-# pattern	The pattern of commands being imported (like "foo::*")
-#               a canonical namespace as returned by [namespace current]
-
-proc auto_import {pattern} {
-    global auto_index
-
-    # If no namespace is specified, this will be an error case
-
-    if {![string match *::* $pattern]} {
-	return
-    }
-
-    set ns [uplevel 1 [list ::namespace current]]
-    set patternList [auto_qualify $pattern $ns]
-
-    auto_load_index
-
-    foreach pattern $patternList {
-        foreach name [array names auto_index $pattern] {
-            if {([namespace which -command $name] eq "")
-		    && ([namespace qualifiers $pattern] eq [namespace qualifiers $name])} {
-                namespace eval :: $auto_index($name)
-            }
-        }
-    }
-}
-
-# auto_execok --
-#
-# Returns string that indicates name of program to execute if
-# name corresponds to a shell builtin or an executable in the
-# Windows search path, or "" otherwise.  Builds an associative
-# array auto_execs that caches information about previous checks,
-# for speed.
-#
-# Arguments:
-# name -			Name of a command.
-
-if {$tcl_platform(platform) eq "windows"} {
-# Windows version.
-#
-# Note that info executable doesn't work under Windows, so we have to
-# look for files with .exe, .com, or .bat extensions.  Also, the path
-# may be in the Path or PATH environment variables, and path
-# components are separated with semicolons, not colons as under Unix.
-#
-proc auto_execok name {
-    global auto_execs env tcl_platform
-
-    if {[info exists auto_execs($name)]} {
-	return $auto_execs($name)
-    }
-    set auto_execs($name) ""
-
-    set shellBuiltins [list cls copy date del dir echo erase md mkdir \
-	    mklink rd ren rename rmdir start time type ver vol]
-    if {[info exists env(PATHEXT)]} {
-	# Add an initial ; to have the {} extension check first.
-	set execExtensions [split ";$env(PATHEXT)" ";"]
-    } else {
-	set execExtensions [list {} .com .exe .bat .cmd]
-    }
-
-    if {[string tolower $name] in $shellBuiltins} {
-	# When this is command.com for some reason on Win2K, Tcl won't
-	# exec it unless the case is right, which this corrects.  COMSPEC
-	# may not point to a real file, so do the check.
-	set cmd $env(COMSPEC)
-	if {[file exists $cmd]} {
-	    set cmd [file attributes $cmd -shortname]
-	}
-	return [set auto_execs($name) [list $cmd /c $name]]
-    }
-
-    if {[llength [file split $name]] != 1} {
-	foreach ext $execExtensions {
-	    set file ${name}${ext}
-	    if {[file exists $file] && ![file isdirectory $file]} {
-		return [set auto_execs($name) [list $file]]
-	    }
-	}
-	return ""
-    }
-
-    set path "[file dirname [info nameof]];.;"
-    if {[info exists env(WINDIR)]} {
-	set windir $env(WINDIR)
-    }
-    if {[info exists windir]} {
-	if {$tcl_platform(os) eq "Windows NT"} {
-	    append path "$windir/system32;"
-	}
-	append path "$windir/system;$windir;"
-    }
-
-    foreach var {PATH Path path} {
-	if {[info exists env($var)]} {
-	    append path ";$env($var)"
-	}
-    }
-
-    foreach ext $execExtensions {
-	unset -nocomplain checked
-	foreach dir [split $path {;}] {
-	    # Skip already checked directories
-	    if {[info exists checked($dir)] || ($dir eq "")} {
-		continue
-	    }
-	    set checked($dir) {}
-	    set file [file join $dir ${name}${ext}]
-	    if {[file exists $file] && ![file isdirectory $file]} {
-		return [set auto_execs($name) [list $file]]
-	    }
-	}
-    }
-    return ""
-}
-
-} else {
-# Unix version.
-#
-proc auto_execok name {
-    global auto_execs env
-
-    if {[info exists auto_execs($name)]} {
-	return $auto_execs($name)
-    }
-    set auto_execs($name) ""
-    if {[llength [file split $name]] != 1} {
-	if {[file executable $name] && ![file isdirectory $name]} {
-	    set auto_execs($name) [list $name]
-	}
-	return $auto_execs($name)
-    }
-    foreach dir [split $env(PATH) :] {
-	if {$dir eq ""} {
-	    set dir .
-	}
-	set file [file join $dir $name]
-	if {[file executable $file] && ![file isdirectory $file]} {
-	    set auto_execs($name) [list $file]
-	    return $auto_execs($name)
-	}
-    }
-    return ""
-}
-
-}
-
-# ::tcl::CopyDirectory --
-#
-# This procedure is called by Tcl's core when attempts to call the
-# filesystem's copydirectory function fail.  The semantics of the call
-# are that 'dest' does not yet exist, i.e. dest should become the exact
-# image of src.  If dest does exist, we throw an error.
-#
-# Note that making changes to this procedure can change the results
-# of running Tcl's tests.
-#
-# Arguments:
-# action -              "renaming" or "copying"
-# src -			source directory
-# dest -		destination directory
-proc tcl::CopyDirectory {action src dest} {
-    set nsrc [file normalize $src]
-    set ndest [file normalize $dest]
-
-    if {$action eq "renaming"} {
-	# Can't rename volumes.  We could give a more precise
-	# error message here, but that would break the test suite.
-	if {$nsrc in [file volumes]} {
-	    return -code error "error $action \"$src\" to\
-	      \"$dest\": trying to rename a volume or move a directory\
-	      into itself"
-	}
-    }
-    if {[file exists $dest]} {
-	if {$nsrc eq $ndest} {
-	    return -code error "error $action \"$src\" to\
-	      \"$dest\": trying to rename a volume or move a directory\
-	      into itself"
-	}
-	if {$action eq "copying"} {
-	    # We used to throw an error here, but, looking more closely
-	    # at the core copy code in tclFCmd.c, if the destination
-	    # exists, then we should only call this function if -force
-	    # is true, which means we just want to over-write.  So,
-	    # the following code is now commented out.
-	    #
-	    # return -code error "error $action \"$src\" to\
-	    # \"$dest\": file already exists"
-	} else {
-	    # Depending on the platform, and on the current
-	    # working directory, the directories '.', '..'
-	    # can be returned in various combinations.  Anyway,
-	    # if any other file is returned, we must signal an error.
-	    set existing [glob -nocomplain -directory $dest * .*]
-	    lappend existing {*}[glob -nocomplain -directory $dest \
-		    -type hidden * .*]
-	    foreach s $existing {
-		if {[file tail $s] ni {. ..}} {
-		    return -code error "error $action \"$src\" to\
-		      \"$dest\": file already exists"
-		}
-	    }
-	}
-    } else {
-	if {[string first $nsrc $ndest] != -1} {
-	    set srclen [expr {[llength [file split $nsrc]] - 1}]
-	    set ndest [lindex [file split $ndest] $srclen]
-	    if {$ndest eq [file tail $nsrc]} {
-		return -code error "error $action \"$src\" to\
-		  \"$dest\": trying to rename a volume or move a directory\
-		  into itself"
-	    }
-	}
-	file mkdir $dest
-    }
-    # Have to be careful to capture both visible and hidden files.
-    # We will also be more generous to the file system and not
-    # assume the hidden and non-hidden lists are non-overlapping.
-    #
-    # On Unix 'hidden' files begin with '.'.  On other platforms
-    # or filesystems hidden files may have other interpretations.
-    set filelist [concat [glob -nocomplain -directory $src *] \
-      [glob -nocomplain -directory $src -types hidden *]]
-
-    foreach s [lsort -unique $filelist] {
-	if {[file tail $s] ni {. ..}} {
-	    file copy -force -- $s [file join $dest [file tail $s]]
-	}
-    }
-    return
-}
Index: venv/Lib/site-packages/Events-0.4-py3.6.egg-info/top_level.txt
===================================================================
diff --git a/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/top_level.txt b/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/top_level.txt
deleted file mode 100644
--- a/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/top_level.txt	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
+++ /dev/null	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
@@ -1,1 +0,0 @@
-events
Index: venv/Lib/site-packages/Events-0.4-py3.6.egg-info/installed-files.txt
===================================================================
diff --git a/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/installed-files.txt b/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/installed-files.txt
deleted file mode 100644
--- a/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/installed-files.txt	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
+++ /dev/null	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
@@ -1,12 +0,0 @@
-..\events\__init__.py
-..\events\__pycache__\__init__.cpython-36.pyc
-..\events\__pycache__\events.cpython-36.pyc
-..\events\events.py
-..\events\tests\__init__.py
-..\events\tests\__pycache__\__init__.cpython-36.pyc
-..\events\tests\__pycache__\tests.cpython-36.pyc
-..\events\tests\tests.py
-PKG-INFO
-SOURCES.txt
-dependency_links.txt
-top_level.txt
Index: venv/Lib/site-packages/Events-0.4-py3.6.egg-info/SOURCES.txt
===================================================================
diff --git a/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/SOURCES.txt b/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/SOURCES.txt
deleted file mode 100644
--- a/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/SOURCES.txt	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
+++ /dev/null	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
@@ -1,13 +0,0 @@
-LICENSE
-MANIFEST.in
-README.rst
-setup.cfg
-setup.py
-Events.egg-info/PKG-INFO
-Events.egg-info/SOURCES.txt
-Events.egg-info/dependency_links.txt
-Events.egg-info/top_level.txt
-events/__init__.py
-events/events.py
-events/tests/__init__.py
-events/tests/tests.py
\ No newline at end of file
Index: venv/Lib/site-packages/Events-0.4-py3.6.egg-info/dependency_links.txt
===================================================================
diff --git a/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/dependency_links.txt b/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/dependency_links.txt
deleted file mode 100644
--- a/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/dependency_links.txt	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
+++ /dev/null	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
@@ -1,1 +0,0 @@
-
Index: venv/Lib/site-packages/Events-0.4-py3.6.egg-info/PKG-INFO
===================================================================
diff --git a/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/PKG-INFO b/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/PKG-INFO
deleted file mode 100644
--- a/venv/Lib/site-packages/Events-0.4-py3.6.egg-info/PKG-INFO	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
+++ /dev/null	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
@@ -1,128 +0,0 @@
-Metadata-Version: 1.1
-Name: Events
-Version: 0.4
-Summary: Bringing the elegance of C# EventHandler to Python
-Home-page: http://github.com/pyeve/events
-Author: Nicola Iarocci
-Author-email: nicola@nicolaiarocci.com
-License: BSD
-Description: Events 
-        ------
-        
-        The C# language provides a handy way to declare, subscribe to and fire events.
-        Technically, an event is a "slot" where callback functions (event handlers) can
-        be attached to - a process referred to as subscribing to an event. Here is
-        a handy package that encapsulates the core to event subscription and event
-        firing and feels like a "natural" part of the language.
-        
-        ::
-         
-            >>> def something_changed(reason): 
-            ...     print "something changed because %s" % reason 
-        
-            >>> from events import Events
-            >>> events = Events()
-            >>> events.on_change += something_changed
-        
-        Multiple callback functions can subscribe to the same event. When the event is
-        fired, all attached event handlers are invoked in sequence. To fire the event,
-        perform a call on the slot: 
-        
-        ::
-        
-            >>> events.on_change('it had to happen')
-            'something changed because it had to happen'
-        
-        By default, Events does not check if an event can be subscribed to and fired.
-        You can predefine events by subclassing Events and listing them. Attempts to
-        subscribe to or fire an undefined event will raise an EventsException.
-        
-        ::
-        
-            >>> class MyEvents(Events):
-            ...     __events__ = ('on_this', 'on_that', )
-        
-            >>> events = MyEvents()
-        
-            # this will raise an EventsException as `on_change` is unknown to MyEvents:
-            >>> events.on_change += something_changed
-        
-        You can also predefine events for a single Events instance by passing an
-        iterator to the constructor.
-        
-        ::
-        
-            >>> events = Events(('on_this', 'on_that'))
-        
-            # this will raise an EventsException as `on_change` is unknown to events:
-            >>> events.on_change += something_changed
-        
-        
-        Unsubscribing
-        -------------
-        There may come a time when you no longer want to be notified of an event. In
-        this case, you unsubscribe in the natural counterpart to `+=` by using `-=`.
-        
-        ::
-        
-            # We no longer want to be notified, take us out of the event callback list
-            >>> events.on_change -= something_changed
-        
-        
-        You may also want to unsubscribe for memory management reasons. The `Events()` instance
-        will hold a reference `something_changed`. If this is a member method of an object,
-        and the lifetime of the `Events()` instance is greater than that object, it will keep
-        it around longer than would be the normal case.
-        
-        Documentation
-        -------------
-        Complete documentation is available at http://events.readthedocs.org
-        
-        Installing
-        ----------
-        Events is on PyPI so all you need to do is:
-        
-        ::
-        
-            pip install events
-        
-        Testing
-        -------
-        Just run:
-        
-        ::
-        
-            python setup.py test
-        
-        Or use tox to test the package under all supported Pythons: 2.7, 3.4+
-        
-        Licenseing
-        ----------
-        Events is BSD licensed. See the LICENSE_ for details.
-        
-        Contributing
-        ------------
-        Please see the `Contribution Guidelines`_.
-        
-        Attribution
-        -----------
-        Based on the excellent recipe by `Zoran Isailovski`_, Copyright (c) 2005.
-        
-        .. _`Contribution Guidelines`: https://github.com/pyeve/events/blob/master/CONTRIBUTING.rst
-        .. _LICENSE: https://github.com/pyeve/events/blob/master/LICENSE 
-        .. _`Zoran Isailovski`: http://code.activestate.com/recipes/410686/
-        
-Platform: any
-Classifier: Development Status :: 4 - Beta
-Classifier: Intended Audience :: Developers
-Classifier: License :: OSI Approved :: BSD License
-Classifier: Operating System :: OS Independent
-Classifier: Programming Language :: Python
-Classifier: Programming Language :: Python :: 2
-Classifier: Programming Language :: Python :: 2.7
-Classifier: Programming Language :: Python :: 3
-Classifier: Programming Language :: Python :: 3.4
-Classifier: Programming Language :: Python :: 3.5
-Classifier: Programming Language :: Python :: 3.7
-Classifier: Programming Language :: Python :: 3.8
-Classifier: Topic :: Software Development
Index: .idea/binance_trade.iml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<module type=\"PYTHON_MODULE\" version=\"4\">\r\n  <component name=\"NewModuleRootManager\">\r\n    <content url=\"file://$MODULE_DIR$\" />\r\n    <orderEntry type=\"inheritedJdk\" />\r\n    <orderEntry type=\"sourceFolder\" forTests=\"false\" />\r\n  </component>\r\n  <component name=\"TestRunnerService\">\r\n    <option name=\"PROJECT_TEST_RUNNER\" value=\"Twisted Trial\" />\r\n  </component>\r\n</module>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/binance_trade.iml b/.idea/binance_trade.iml
--- a/.idea/binance_trade.iml	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
+++ b/.idea/binance_trade.iml	(date 1632847356432)
@@ -1,11 +1,10 @@
 <?xml version="1.0" encoding="UTF-8"?>
 <module type="PYTHON_MODULE" version="4">
   <component name="NewModuleRootManager">
-    <content url="file://$MODULE_DIR$" />
-    <orderEntry type="inheritedJdk" />
+    <content url="file://$MODULE_DIR$">
+      <excludeFolder url="file://$MODULE_DIR$/venv3.9" />
+    </content>
+    <orderEntry type="jdk" jdkName="Python 3.6 (binance_trade)" jdkType="Python SDK" />
     <orderEntry type="sourceFolder" forTests="false" />
   </component>
-  <component name="TestRunnerService">
-    <option name="PROJECT_TEST_RUNNER" value="Twisted Trial" />
-  </component>
-</module>
\ No newline at end of file
+  <compo
\ No newline at end of file
Index: venv/pyvenv.cfg
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>home = C:\\Users\\vahid\\AppData\\Local\\Programs\\Python\\Python36\r\ninclude-system-site-packages = true\r\nversion = 3.6.8\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/venv/pyvenv.cfg b/venv/pyvenv.cfg
--- a/venv/pyvenv.cfg	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
+++ b/venv/pyvenv.cfg	(date 1632847356926)
@@ -1,3 +1,3 @@
-home = C:\Users\vahid\AppData\Local\Programs\Python\Python36
-include-system-site-packages = true
-version = 3.6.8
+home = C:\Users\Arvan User\AppData\Local\Programs\Python\Python36
+implementation = CPython
+version_info = 3.6.4.fi
\ No newline at end of file
Index: venv/Scripts/deactivate.bat
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>@echo off\r\n\r\nif defined _OLD_VIRTUAL_PROMPT (\r\n    set \"PROMPT=%_OLD_VIRTUAL_PROMPT%\"\r\n)\r\nset _OLD_VIRTUAL_PROMPT=\r\n\r\nif defined _OLD_VIRTUAL_PYTHONHOME (\r\n    set \"PYTHONHOME=%_OLD_VIRTUAL_PYTHONHOME%\"\r\n    set _OLD_VIRTUAL_PYTHONHOME=\r\n)\r\n\r\nif defined _OLD_VIRTUAL_PATH (\r\n    set \"PATH=%_OLD_VIRTUAL_PATH%\"\r\n)\r\n\r\nset _OLD_VIRTUAL_PATH=\r\n\r\nset VIRTUAL_ENV=\r\n\r\n:END\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/venv/Scripts/deactivate.bat b/venv/Scripts/deactivate.bat
--- a/venv/Scripts/deactivate.bat	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
+++ b/venv/Scripts/deactivate.bat	(date 1632847356596)
@@ -1,21 +1,13 @@
 @echo off
 
-if defined _OLD_VIRTUAL_PROMPT (
+set VIRTUAL_ENV=
+
+REM Don't use () to avoid problems with them in %PATH%
+if not defined _OLD_VIRTUAL_PROMPT goto ENDIFVPROMPT
     set "PROMPT=%_OLD_VIRTUAL_PROMPT%"
-)
-set _OLD_VIRTUAL_PROMPT=
+    set _OLD_VIRTUAL_PROMPT=
+:ENDIFVPROMPT
 
-if defined _OLD_VIRTUAL_PYTHONHOME (
+if not defined _OLD_VIRTUAL_PYTHONHOME goto ENDIFVHOME
     set "PYTHONHOME=%_OLD_VIRTUAL_PYTHONHOME%"
     set _OLD_VIRTUAL_PYTHONHOME=
-)
-
-if defined _OLD_VIRTUAL_PATH (
-    set "PATH=%_OLD_VIRTUAL_PATH%"
-)
-
-set _OLD_VIRTUAL_PATH=
-
-set VIRTUAL_ENV=
-
-:END
Index: venv/Scripts/activate
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># This file must be used with \"source bin/activate\" *from bash*\r\n# you cannot run it directly\r\n\r\ndeactivate () {\r\n    # reset old environment variables\r\n    if [ -n \"${_OLD_VIRTUAL_PATH:-}\" ] ; then\r\n        PATH=\"${_OLD_VIRTUAL_PATH:-}\"\r\n        export PATH\r\n        unset _OLD_VIRTUAL_PATH\r\n    fi\r\n    if [ -n \"${_OLD_VIRTUAL_PYTHONHOME:-}\" ] ; then\r\n        PYTHONHOME=\"${_OLD_VIRTUAL_PYTHONHOME:-}\"\r\n        export PYTHONHOME\r\n        unset _OLD_VIRTUAL_PYTHONHOME\r\n    fi\r\n\r\n    # This should detect bash and zsh, which have a hash command that must\r\n    # be called to get it to forget past commands.  Without forgetting\r\n    # past commands the $PATH changes we made may not be respected\r\n    if [ -n \"${BASH:-}\" -o -n \"${ZSH_VERSION:-}\" ] ; then\r\n        hash -r\r\n    fi\r\n\r\n    if [ -n \"${_OLD_VIRTUAL_PS1:-}\" ] ; then\r\n        PS1=\"${_OLD_VIRTUAL_PS1:-}\"\r\n        export PS1\r\n        unset _OLD_VIRTUAL_PS1\r\n    fi\r\n\r\n    unset VIRTUAL_ENV\r\n    if [ ! \"$1\" = \"nondestructive\" ] ; then\r\n    # Self destruct!\r\n        unset -f deactivate\r\n    fi\r\n}\r\n\r\n# unset irrelevant variables\r\ndeactivate nondestructive\r\n\r\nVIRTUAL_ENV=\"C:\\Users\\vahid\\Documents\\Project\\BInance\\venv\"\r\nexport VIRTUAL_ENV\r\n\r\n_OLD_VIRTUAL_PATH=\"$PATH\"\r\nPATH=\"$VIRTUAL_ENV/Scripts:$PATH\"\r\nexport PATH\r\n\r\n# unset PYTHONHOME if set\r\n# this will fail if PYTHONHOME is set to the empty string (which is bad anyway)\r\n# could use `if (set -u; : $PYTHONHOME) ;` in bash\r\nif [ -n \"${PYTHONHOME:-}\" ] ; then\r\n    _OLD_VIRTUAL_PYTHONHOME=\"${PYTHONHOME:-}\"\r\n    unset PYTHONHOME\r\nfi\r\n\r\nif [ -z \"${VIRTUAL_ENV_DISABLE_PROMPT:-}\" ] ; then\r\n    _OLD_VIRTUAL_PS1=\"${PS1:-}\"\r\n    if [ \"x(venv) \" != x ] ; then\r\n\tPS1=\"(venv) ${PS1:-}\"\r\n    else\r\n    if [ \"`basename \\\"$VIRTUAL_ENV\\\"`\" = \"__\" ] ; then\r\n        # special case for Aspen magic directories\r\n        # see http://www.zetadev.com/software/aspen/\r\n        PS1=\"[`basename \\`dirname \\\"$VIRTUAL_ENV\\\"\\``] $PS1\"\r\n    else\r\n        PS1=\"(`basename \\\"$VIRTUAL_ENV\\\"`)$PS1\"\r\n    fi\r\n    fi\r\n    export PS1\r\nfi\r\n\r\n# This should detect bash and zsh, which have a hash command that must\r\n# be called to get it to forget past commands.  Without forgetting\r\n# past commands the $PATH changes we made may not be respected\r\nif [ -n \"${BASH:-}\" -o -n \"${ZSH_VERSION:-}\" ] ; then\r\n    hash -r\r\nfi\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/venv/Scripts/activate b/venv/Scripts/activate
--- a/venv/Scripts/activate	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
+++ b/venv/Scripts/activate	(date 1632847356593)
@@ -1,34 +1,41 @@
 # This file must be used with "source bin/activate" *from bash*
 # you cannot run it directly
 
+
+if [ "${BASH_SOURCE-}" = "$0" ]; then
+    echo "You must source this script: \$ source $0" >&2
+    exit 33
+fi
+
 deactivate () {
+    unset -f pydoc >/dev/null 2>&1 || true
+
     # reset old environment variables
-    if [ -n "${_OLD_VIRTUAL_PATH:-}" ] ; then
-        PATH="${_OLD_VIRTUAL_PATH:-}"
+    # ! [ -z ${VAR+_} ] returns true if VAR is declared at all
+    if ! [ -z "${_OLD_VIRTUAL_PATH:+_}" ] ; then
+        PATH="$_OLD_VIRTUAL_PATH"
         export PATH
         unset _OLD_VIRTUAL_PATH
     fi
-    if [ -n "${_OLD_VIRTUAL_PYTHONHOME:-}" ] ; then
-        PYTHONHOME="${_OLD_VIRTUAL_PYTHONHOME:-}"
+    if ! [ -z "${_OLD_VIRTUAL_PYTHONHOME+_}" ] ; then
+        PYTHONHOME="$_OLD_VIRTUAL_PYTHONHOME"
         export PYTHONHOME
         unset _OLD_VIRTUAL_PYTHONHOME
     fi
 
-    # This should detect bash and zsh, which have a hash command that must
-    # be called to get it to forget past commands.  Without forgetting
-    # past commands the $PATH changes we made may not be respected
-    if [ -n "${BASH:-}" -o -n "${ZSH_VERSION:-}" ] ; then
-        hash -r
-    fi
+    # The hash command must be called to get it to forget past
+    # commands. Without forgetting past commands the $PATH changes
+    # we made may not be respected
+    hash -r 2>/dev/null
 
-    if [ -n "${_OLD_VIRTUAL_PS1:-}" ] ; then
-        PS1="${_OLD_VIRTUAL_PS1:-}"
+    if ! [ -z "${_OLD_VIRTUAL_PS1+_}" ] ; then
+        PS1="$_OLD_VIRTUAL_PS1"
         export PS1
         unset _OLD_VIRTUAL_PS1
     fi
 
     unset VIRTUAL_ENV
-    if [ ! "$1" = "nondestructive" ] ; then
+    if [ ! "${1-}" = "nondestructive" ] ; then
     # Self destruct!
         unset -f deactivate
     fi
@@ -37,7 +44,10 @@
 # unset irrelevant variables
 deactivate nondestructive
 
-VIRTUAL_ENV="C:\Users\vahid\Documents\Project\BInance\venv"
+VIRTUAL_ENV='C:\Users\Arvan User\PycharmProjects\binance_trade\venv'
+if ([ "$OSTYPE" = "cygwin" ] || [ "$OSTYPE" = "msys" ]) && $(command -v cygpath &> /dev/null) ; then
+    VIRTUAL_ENV=$(cygpath -u "$VIRTUAL_ENV")
+fi
 export VIRTUAL_ENV
 
 _OLD_VIRTUAL_PATH="$PATH"
@@ -45,32 +55,29 @@
 export PATH
 
 # unset PYTHONHOME if set
-# this will fail if PYTHONHOME is set to the empty string (which is bad anyway)
-# could use `if (set -u; : $PYTHONHOME) ;` in bash
-if [ -n "${PYTHONHOME:-}" ] ; then
-    _OLD_VIRTUAL_PYTHONHOME="${PYTHONHOME:-}"
+if ! [ -z "${PYTHONHOME+_}" ] ; then
+    _OLD_VIRTUAL_PYTHONHOME="$PYTHONHOME"
     unset PYTHONHOME
 fi
 
-if [ -z "${VIRTUAL_ENV_DISABLE_PROMPT:-}" ] ; then
-    _OLD_VIRTUAL_PS1="${PS1:-}"
-    if [ "x(venv) " != x ] ; then
-	PS1="(venv) ${PS1:-}"
+if [ -z "${VIRTUAL_ENV_DISABLE_PROMPT-}" ] ; then
+    _OLD_VIRTUAL_PS1="${PS1-}"
+    if [ "x" != x ] ; then
+        PS1="${PS1-}"
     else
-    if [ "`basename \"$VIRTUAL_ENV\"`" = "__" ] ; then
-        # special case for Aspen magic directories
-        # see http://www.zetadev.com/software/aspen/
-        PS1="[`basename \`dirname \"$VIRTUAL_ENV\"\``] $PS1"
-    else
-        PS1="(`basename \"$VIRTUAL_ENV\"`)$PS1"
-    fi
+        PS1="(`basename \"$VIRTUAL_ENV\"`) ${PS1-}"
     fi
     export PS1
 fi
 
-# This should detect bash and zsh, which have a hash command that must
-# be called to get it to forget past commands.  Without forgetting
-# past commands the $PATH changes we made may not be respected
-if [ -n "${BASH:-}" -o -n "${ZSH_VERSION:-}" ] ; then
-    hash -r
-fi
+# Make sure to unalias pydoc if it's already there
+alias pydoc 2>/dev/null >/dev/null && unalias pydoc || true
+
+pydoc () {
+    python -m pydoc "$@"
+}
+
+# The hash command must be called to get it to forget past
+# commands. Without forgetting past commands the $PATH changes
+# we made may not be respected
+hash -r 2>/dev/null
Index: venv/Scripts/Activate.ps1
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>function global:deactivate ([switch]$NonDestructive) {\r\n    # Revert to original values\r\n    if (Test-Path function:_OLD_VIRTUAL_PROMPT) {\r\n        copy-item function:_OLD_VIRTUAL_PROMPT function:prompt\r\n        remove-item function:_OLD_VIRTUAL_PROMPT\r\n    }\r\n\r\n    if (Test-Path env:_OLD_VIRTUAL_PYTHONHOME) {\r\n        copy-item env:_OLD_VIRTUAL_PYTHONHOME env:PYTHONHOME\r\n        remove-item env:_OLD_VIRTUAL_PYTHONHOME\r\n    }\r\n\r\n    if (Test-Path env:_OLD_VIRTUAL_PATH) {\r\n        copy-item env:_OLD_VIRTUAL_PATH env:PATH\r\n        remove-item env:_OLD_VIRTUAL_PATH\r\n    }\r\n\r\n    if (Test-Path env:VIRTUAL_ENV) {\r\n        remove-item env:VIRTUAL_ENV\r\n    }\r\n\r\n    if (!$NonDestructive) {\r\n        # Self destruct!\r\n        remove-item function:deactivate\r\n    }\r\n}\r\n\r\ndeactivate -nondestructive\r\n\r\n$env:VIRTUAL_ENV=\"C:\\Users\\vahid\\Documents\\Project\\BInance\\venv\"\r\n\r\nif (! $env:VIRTUAL_ENV_DISABLE_PROMPT) {\r\n    # Set the prompt to include the env name\r\n    # Make sure _OLD_VIRTUAL_PROMPT is global\r\n    function global:_OLD_VIRTUAL_PROMPT {\"\"}\r\n    copy-item function:prompt function:_OLD_VIRTUAL_PROMPT\r\n    function global:prompt {\r\n        Write-Host -NoNewline -ForegroundColor Green '(venv) '\r\n        _OLD_VIRTUAL_PROMPT\r\n    }\r\n}\r\n\r\n# Clear PYTHONHOME\r\nif (Test-Path env:PYTHONHOME) {\r\n    copy-item env:PYTHONHOME env:_OLD_VIRTUAL_PYTHONHOME\r\n    remove-item env:PYTHONHOME\r\n}\r\n\r\n# Add the venv to the PATH\r\ncopy-item env:PATH env:_OLD_VIRTUAL_PATH\r\n$env:PATH = \"$env:VIRTUAL_ENV\\Scripts;$env:PATH\"\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/venv/Scripts/Activate.ps1 b/venv/Scripts/Activate.ps1
--- a/venv/Scripts/Activate.ps1	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
+++ b/venv/Scripts/Activate.ps1	(date 1632847356525)
@@ -1,51 +1,53 @@
-function global:deactivate ([switch]$NonDestructive) {
-    # Revert to original values
-    if (Test-Path function:_OLD_VIRTUAL_PROMPT) {
-        copy-item function:_OLD_VIRTUAL_PROMPT function:prompt
-        remove-item function:_OLD_VIRTUAL_PROMPT
-    }
-
-    if (Test-Path env:_OLD_VIRTUAL_PYTHONHOME) {
-        copy-item env:_OLD_VIRTUAL_PYTHONHOME env:PYTHONHOME
-        remove-item env:_OLD_VIRTUAL_PYTHONHOME
+$script:THIS_PATH = $myinvocation.mycommand.path
+$script:BASE_DIR = Split-Path (Resolve-Path "$THIS_PATH/..") -Parent
+
+function global:deactivate([switch] $NonDestructive) {
+    if (Test-Path variable:_OLD_VIRTUAL_PATH) {
+        $env:PATH = $variable:_OLD_VIRTUAL_PATH
+        Remove-Variable "_OLD_VIRTUAL_PATH" -Scope global
     }
 
-    if (Test-Path env:_OLD_VIRTUAL_PATH) {
-        copy-item env:_OLD_VIRTUAL_PATH env:PATH
-        remove-item env:_OLD_VIRTUAL_PATH
+    if (Test-Path function:_old_virtual_prompt) {
+        $function:prompt = $function:_old_virtual_prompt
+        Remove-Item function:\_old_virtual_prompt
     }
 
-    if (Test-Path env:VIRTUAL_ENV) {
-        remove-item env:VIRTUAL_ENV
+    if ($env:VIRTUAL_ENV) {
+        Remove-Item env:VIRTUAL_ENV -ErrorAction SilentlyContinue
     }
 
     if (!$NonDestructive) {
         # Self destruct!
-        remove-item function:deactivate
+        Remove-Item function:deactivate
+        Remove-Item function:pydoc
     }
 }
+
+function global:pydoc {
+    python -m pydoc $args
+}
 
+# unset irrelevant variables
 deactivate -nondestructive
 
-$env:VIRTUAL_ENV="C:\Users\vahid\Documents\Project\BInance\venv"
+$VIRTUAL_ENV = $BASE_DIR
+$env:VIRTUAL_ENV = $VIRTUAL_ENV
 
-if (! $env:VIRTUAL_ENV_DISABLE_PROMPT) {
-    # Set the prompt to include the env name
-    # Make sure _OLD_VIRTUAL_PROMPT is global
-    function global:_OLD_VIRTUAL_PROMPT {""}
-    copy-item function:prompt function:_OLD_VIRTUAL_PROMPT
-    function global:prompt {
-        Write-Host -NoNewline -ForegroundColor Green '(venv) '
-        _OLD_VIRTUAL_PROMPT
-    }
-}
-
-# Clear PYTHONHOME
-if (Test-Path env:PYTHONHOME) {
-    copy-item env:PYTHONHOME env:_OLD_VIRTUAL_PYTHONHOME
-    remove-item env:PYTHONHOME
-}
-
-# Add the venv to the PATH
-copy-item env:PATH env:_OLD_VIRTUAL_PATH
-$env:PATH = "$env:VIRTUAL_ENV\Scripts;$env:PATH"
+New-Variable -Scope global -Name _OLD_VIRTUAL_PATH -Value $env:PATH
+
+$env:PATH = "$env:VIRTUAL_ENV/Scripts;" + $env:PATH
+if (!$env:VIRTUAL_ENV_DISABLE_PROMPT) {
+    function global:_old_virtual_prompt {
+        ""
+    }
+    $function:_old_virtual_prompt = $function:prompt
+
+    if ("" -ne "") {
+        function global:prompt {
+            # Add the custom prefix to the existing prompt
+            $previous_prompt_value = & $function:_old_virtual_prompt
+            ("" + $previous_prompt_value)
+        }
+    }
+    else {
+        function global:prompt 
\ No newline at end of file
Index: venv/Scripts/activate.bat
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>@echo off\r\n\r\nrem This file is UTF-8 encoded, so we need to update the current code page while executing it\r\nfor /f \"tokens=2 delims=:\" %%a in ('\"%SystemRoot%\\System32\\chcp.com\"') do (\r\n    set \"_OLD_CODEPAGE=%%a\"\r\n)\r\nif defined _OLD_CODEPAGE (\r\n    \"%SystemRoot%\\System32\\chcp.com\" 65001 > nul\r\n)\r\n\r\nset \"VIRTUAL_ENV=C:\\Users\\vahid\\Documents\\Project\\BInance\\venv\"\r\n\r\nif not defined PROMPT (\r\n    set \"PROMPT=$P$G\"\r\n)\r\n\r\nif defined _OLD_VIRTUAL_PROMPT (\r\n    set \"PROMPT=%_OLD_VIRTUAL_PROMPT%\"\r\n)\r\n\r\nif defined _OLD_VIRTUAL_PYTHONHOME (\r\n    set \"PYTHONHOME=%_OLD_VIRTUAL_PYTHONHOME%\"\r\n)\r\n\r\nset \"_OLD_VIRTUAL_PROMPT=%PROMPT%\"\r\nset \"PROMPT=(venv) %PROMPT%\"\r\n\r\nif defined PYTHONHOME (\r\n    set \"_OLD_VIRTUAL_PYTHONHOME=%PYTHONHOME%\"\r\n    set PYTHONHOME=\r\n)\r\n\r\nif defined _OLD_VIRTUAL_PATH (\r\n    set \"PATH=%_OLD_VIRTUAL_PATH%\"\r\n) else (\r\n    set \"_OLD_VIRTUAL_PATH=%PATH%\"\r\n)\r\n\r\nset \"PATH=%VIRTUAL_ENV%\\Scripts;%PATH%\"\r\n\r\n:END\r\nif defined _OLD_CODEPAGE (\r\n    \"%SystemRoot%\\System32\\chcp.com\" %_OLD_CODEPAGE% > nul\r\n    set \"_OLD_CODEPAGE=\"\r\n)\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/venv/Scripts/activate.bat b/venv/Scripts/activate.bat
--- a/venv/Scripts/activate.bat	(revision c137f2b33170f7cbd2891f9f072a23f39906a9c6)
+++ b/venv/Scripts/activate.bat	(date 1632847356594)
@@ -1,45 +1,40 @@
 @echo off
 
-rem This file is UTF-8 encoded, so we need to update the current code page while executing it
-for /f "tokens=2 delims=:" %%a in ('"%SystemRoot%\System32\chcp.com"') do (
-    set "_OLD_CODEPAGE=%%a"
-)
-if defined _OLD_CODEPAGE (
-    "%SystemRoot%\System32\chcp.com" 65001 > nul
-)
-
-set "VIRTUAL_ENV=C:\Users\vahid\Documents\Project\BInance\venv"
-
-if not defined PROMPT (
-    set "PROMPT=$P$G"
-)
+set "VIRTUAL_ENV=C:\Users\Arvan User\PycharmProjects\binance_trade\venv"
 
 if defined _OLD_VIRTUAL_PROMPT (
     set "PROMPT=%_OLD_VIRTUAL_PROMPT%"
-)
-
-if defined _OLD_VIRTUAL_PYTHONHOME (
-    set "PYTHONHOME=%_OLD_VIRTUAL_PYTHONHOME%"
-)
-
-set "_OLD_VIRTUAL_PROMPT=%PROMPT%"
-set "PROMPT=(venv) %PROMPT%"
+) else (
+    if not defined PROMPT (
+        set "PROMPT=$P$G"
+    )
+    if not defined VIRTUAL_ENV_DISABLE_PROMPT (
+        set "_OLD_VIRTUAL_PROMPT=%PROMPT%"
+    )
+)
+if not defined VIRTUAL_ENV_DISABLE_PROMPT (
+    set "ENV_PROMPT="
+    if NOT DEFINED ENV_PROMPT (
+        for %%d in ("%VIRTUAL_ENV%") do set "ENV_PROMPT=(%%~nxd) "
+    )
+    )
+    set "PROMPT=%ENV_PROMPT%%PROMPT%"
+)
 
-if defined PYTHONHOME (
+REM Don't use () to avoid problems with them in %PATH%
+if defined _OLD_VIRTUAL_PYTHONHOME goto ENDIFVHOME
     set "_OLD_VIRTUAL_PYTHONHOME=%PYTHONHOME%"
-    set PYTHONHOME=
-)
+:ENDIFVHOME
+
+set PYTHONHOME=
 
-if defined _OLD_VIRTUAL_PATH (
+REM if defined _OLD_VIRTUAL_PATH (
+if not defined _OLD_VIRTUAL_PATH goto ENDIFVPATH1
     set "PATH=%_OLD_VIRTUAL_PATH%"
-) else (
+:ENDIFVPATH1
+REM ) else (
+if defined _OLD_VIRTUAL_PATH goto ENDIFVPATH2
     set "_OLD_VIRTUAL_PATH=%PATH%"
-)
+:ENDIFVPATH2
 
-set "PATH=%VIRTUAL_ENV%\Scripts;%PATH%"
-
-:END
-if defined _OLD_CODEPAGE (
-    "%SystemRoot%\System32\chcp.com" %_OLD_CODEPAGE% > nul
-    set "_OLD_CODEPAGE="
-)
+set "PATH=%VIRTUAL_ENV%\Scripts;%PAT
\ No newline at end of file
